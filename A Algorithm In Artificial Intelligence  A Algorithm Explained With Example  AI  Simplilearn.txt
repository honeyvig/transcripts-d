hey everyone welcome to another video by
simply learn in this video a star
algorithm going to teach you everything
that you need to know about the a star
algorithm which is a path finding
algorithm used to find the shortest
distance between two points
so
let's get started
before we dive into this video let's
take a look at what you can expect to
learn by the end of this video
what's in it for you
first we're gonna answer the burning
question that you have in your mind
what is the star algorithm
next we're going to take a look at the
basic concept behind the a star
algorithm and the mathematical function
which makes it tick
then we'll talk about how the a-star
algorithm works with the help of a case
study
then we'll take a look at the flowchart
of the astar algorithm using which you
can implement the ester algorithm in any
programming language and finally we'll
take a look at how the a star algorithm
can be implemented with the help of
python
so
what is the astar algorithm
before we talk about the a star
algorithm let's talk a bit about search
algorithms
in computer science a search algorithm
is an algorithm which typically solves a
search problem
they are used to retrieve information
which is stored within some data
structure like arrays stacks
trees hash buckets etc
or calculate
the search space of a problem domain
either with discrete or continuous
variables
so consider you have a stack s which
contains four elements
now a stack is an ordered collection of
items
in which you can add a new item and
remove an existing item at the same time
in stacks you can put in an item on top
of another item and you can't access the
elements below the top element without
removing the top element first
so suppose we want to find
the index of say an element in the stack
say 64.
so we're gonna run it through a search
algorithm to find 64 within our data
structure
what this search algorithm is gonna do
is that it's going to take a look at the
top element and see that it's not 64.
it's going to remove the top element and
move on to the next element
again it's going to compare and see if
it's 64.
if it's not this element 2 will get
removed and then it will move on to the
next element in the stack which is 64.
in this case it's going to return the
index of this element
which is at stack index 2
and using stack index 2 we can access
this element so in a way we found the
element in the stack
this is how search algorithms work
this is just an instance or a criteria
on which we were searching
but using search algorithms you can have
multiple different search conditions so
you can search for every element which
is below a certain number say
40 within this stack
or you can also search for elements
which are at a certain index so this is
how powerful search algorithms are
some examples of search algorithms
include binary search linear search
jump search interpolation search etc
now a vital aspect of search algorithms
is pathfinding which is used to find
paths that can be taken to traverse from
one point to another by finding the most
optimum route
the a star algorithm is one algorithm
like this it is a searching algorithm
that is used to find the shortest path
between an initial and a final point
so assume that you have a grid or a maze
in this case
your person as it is at the start
and they have to reach the end of the
maze which is here at this point
denoted by this flag
now using a star algorithm
we can perform map traversal and find
the shortest path which has to be taken
within a map to go from the starting
position to the end position
now in this case there are many
different paths that can be taken
one option is to go along the top edges
of the map
the other one is to go along the bottom
edges
and the shortest path as you can see
which takes only four grids is to go
directly through the center of the
map cut across this diagonal and reach
the end
now one major aspect of a star algorithm
is that it always takes the shorter
paths first
which makes it an optimal and complete
algorithm
an optimal algorithm will find the least
cost outcome for a problem while a
complete algorithm finds all the
possible outcomes of a problem
astr algorithm combines all of these to
find all the possible outcomes of a
problem starting with the least cost
solution
now this is what makes a star algorithm
so handy
a star was initially designed as a graph
traversal problem to help build a robot
that can find its own course
and because of this it still remains a
widely popular algorithm for graph
traversal
now let's take a look at the basic
concept behind the a star algorithm
we already know that a star algorithm is
an optimal and complete algorithm
but another aspect that makes it so
powerful is the use of weighted graphs
in its implementation
a weighted graph is nothing but a graph
which uses numbers to represent the cost
of taking each path or course of action
this means that the algorithms can take
the path with the least cost and find
the best route in terms of distance and
time
in path finding algorithms
for algorithms such as a star you're
obviously going to need a graph or a map
or a path to travel right
so
for computers we feed in something
called a graph
a graph contains of two major components
first
it contains something called a node
so this is a node
and it contains something called a path
a path is nothing
but a line which connects two nodes
using this we know the
direction or the path that we have to
take when we're traversing through our
graph right so um first let's just make
a very simple graph okay right now we
have two nodes a and b i'm just gonna
add two more
c
and d
now this connection with four nodes a b
c and d and their paths is called a
graph this whole thing basically this
whole thing is your graph
these are the graphs that these
algorithms will have to travel through
and find the shortest distance on
so now how do we know where we need to
go in our graph
for this we have something called a
start node and an end node
so let's say
our a
is nothing but a start node
and i see
over here
this node
is our end
node
right so now we know that we have to go
from this node a
all the way to this node c
in this case it becomes very easy i can
either go from a
to b to c or from a to d to c
but how do i know which path is the most
optimum path or the path which has the
least cost
this is made very easy by the use of
weighted graphs this is a basic graph
but in weighted graphs all these paths
between nodes
have a certain
weight to them or a certain number
assigned to them
like say let's just say this is 2 the
cost of this path is 3
this path has a cost of 5
and this path has a cost of 1. so now as
you can see we've assigned numbers to
the paths between different nodes
these numbers tell us the cost of
traversing through that path
so when i take this path between a to b
i have i get a cost of 2
incurred on me and when i go from b to c
i have a cost of 3.
similarly when i go from a to d if i
take this part i'll have a cost of 5 and
d to c will have a cost of 1.
so this helps us in finding out which
parts we should be taking when we're
traversing from one node to the other
now in this case let's look at the
different possible parts we can take to
reach c
the first option is that we go from a
to b
and this will give us a cost of 2
and then from b
we go to c
which will give us a cost of 3.
now the total cost of taking these parts
can easily be obtained
by finding the summation of the
individual cost of these parts
so this will give us five
all we have to do is add up the weights
that each path has when we're traveling
it and we get to know what is going to
be the cost of a path taken so a path a
b to c has a cost of 5.
similarly our path a to d
and d to c
has a cost of five plus one because a to
d is five and d two c is one which is
six
so between five and six
we know that five is lesser
which means that this path a to b to c
is going to be a least cost path and
that is the path that we should be
taking
so a star algorithm makes use of
something called weighted graphs right
so a star algorithm makes use of these
graphs in these ways
now let's
consider that i have
some other node here let's say that i
have a node
e
okay
now b is connected to e
and e is also connected to c
let's say
that the cost of taking this path b to e
is 1
and e to c
is zero
so now let's calculate the cost of
taking the path a b e and c okay
so
a to b
to e to c
is nothing but
2
plus 1
plus 0 which is equal to 3
when compared to a to
b to c
which is nothing but two plus three
which is five
and a to d to c which is nothing but
five plus one which is six
this path is obviously going to be the
shorter path right
but let's consider our programmer or
let's say we ourselves
don't actually want to take this path
because coding for it is hard or because
it's very much isolated from the map
so we prefer to go transverse along some
other nodes
and this is not a preferred node but
looking at the graph no matter what we
do depending on how the weights are
distributed
we are still going to have to go via
this node
now
to overcome this
programmers make use of something called
heuristic values
what are heuristic values so far using a
weighted graph we've given importance to
our paths we found out which paths are
the easiest to take and which paths
are the ones which give us a higher cost
of implementation
now using heuristic values we're gonna
do the same to our nodes the heuristic
value of a node in a graph attempts to
capture the importance of that node's
value within that graph
so the heuristic value is nothing but an
arbitrary value which is assigned to
these nodes
based on the programmers whims and needs
just like how we have the weightage of
paths the heuristic value gives us the
weight of a node
and tells us
how expensive it is to traverse through
that node it is represented
by h of n
so now let's assign heuristic values to
our graph and understand how exactly it
changes
how we traverse this graph right so
let's say our initial start node a has a
heuristic value of one
and our node b has a heuristic value of
say
three
a node e which is out of the way and
which we don't really want to traverse
much on
we can assign a very high heuristic
value to it to ensure that it's not a
path which is regularly taken
so we can assign a heuristic value of 10
to e
let's assign other arbitrary values to
the other nodes let's give d a heuristic
value of 1 and see a heuristic value of
0.
so now as you can see
even though the paths over here take on
a very short value it would become a lot
more expensive to traverse through e
just because of its single high
heuristic value as compared to the other
nodes
how does
having a heuristic value in our graph
change how
we are traversing
so after implementing the heuristic
value
to our graph we now have two major
values which come into the play the
heuristic value
which is nothing but the value of the
node and the
path
weight
we can represent this as g of n
which is nothing but the weights in our
weighted graph right
so as you can see when we're traversing
from one node a to a node b we're gonna
have to consider both of these values
so the cost function of a graph or the
total cost of taking a path
becomes the value of the path weight
which is given by the weighted graph
along with the heuristic value which is
assigned by the programmer or by you
yourself
and this here is the basic function
behind our a star algorithm
this is the formula that our a star
algorithm works on
so initially the a star algorithm will
calculate the cost to all of its
immediate neighboring nodes and choose
the one which is incurring the least
cost this whole process will repeat
until no new nodes can be chosen and all
the paths have been traversed
and then you should consider the best
path among them
and how do you find
the cost function again you're just
gonna add up the heuristic value and the
path value that you've taken
now g of n which is the path value is
nothing but the cost of traversing from
one node to another
very obviously this will vary from node
to node
whereas h of n or heuristic
approximation of a nodes value is not a
real value but an approximation cost
that you or some other person has
assigned to various nodes
now that we know the basic
concept behind the a star algorithm
let's take a look at how exactly the a
star algorithm works with the help of a
case study
so now let's take a look at how the a
star algorithm works
to do this we're first gonna consider a
weighted graph since a star algorithm
uses weighted graphs
to make its calculations easier
so consider this to be
our weighted graph we have a node a
a node b
a node c
a node
d and a node
e
okay
now node a is connected to node b
node b is connected to node e
node e is connected to node d
d is connected to c and c in turn is
connected to a
c is also connected to b
and a is also connected to e
so now let's assign the path values to
all the different parts in our weighted
graph let's say a to b has a path value
of one
b to e has a path value of six
d to e has a path value of
5
c to d has a path value of 9
a to c has a path value of 10
and a to e has a path value of 2
and this has a path value of 3.
now let's assign heuristic values let's
give a the heuristic value of 2
a b is a heuristic value of
5
let's just give this
a 7. let's
make this
four
and let's give c a heuristic value zero
okay
so now this is what a weighted graph
looks like
and
from the basic
working you already know
that the cost function
of your weighted graph
is nothing
but the path value
along with the
heuristic value
so let's
now
say
that
a here is where we have to start from
and e
and e is our
target node
okay
and this is where we are going to be
starting from
now a is our starting node so there are
three different parts that we can take a
to b
a to c or a to e
so first let's consider that we take a
to b okay
the first thing that you have to
consider is the heuristic value of a
itself
so
f of a
is the first value that you're going to
be considering
right
now f of a here is going to be the
uh path value plus heuristic value
now because a is the starting node and
there's no other node leading up to it
it is the parent node itself so the path
value here is going to be 0 because
there's no path leading up to it it's
the starting node and the starting node
always has a path value of 0.
next we're going to add the heuristic
value of a in this case 2
so 0 plus 2
so f of a is 2
right
so this is the first node
that you've
considered
okay
now
after taking node a we have three
different options a to c a to e or a to
b
so
the cost function of taking the path a
to b
is going to be so now let's find the
cost of taking the path a to b
right a to b so you have to add the
graph node value plus a heuristic value
the weight of taking the node a to b is
nothing but 1
and
the heuristic value of b is 5
so this is going to give us c
next
a
to see
so i study
next let's look at the cost of taking
the path a to e right
f of
a to
e
so this is going to be 2 because the
cost of taking this path is 2
along with the heuristic value of e
which is
7
so this is going to be 9
and let's look at f of
a to
c now the cost of taking this is going
to be 10
plus the value of c which is 0.
so this is going to be 10.
now the way how a star algorithm works
is it will calculate the cost function
of all the neighboring nodes
and go with the node which has the least
cost function
in this case the node being b
so we're not going to take this path or
this path
because the cost function value is way
more than the cost function value of f
of a to b
so after a we are going to be at node b
so right now
this is the direction that we've
traveled in
now when we're at node b
to reach node e we have two different
options such we have two options that we
can take we can either go from b to e or
we can go from b to c
okay
uh the goal of a star algorithm is to
always minimize
the cost of the path that you are taking
so using this in mind let's calculate
f of
b to c
which is going to be nothing but
the cost of the path from b to c
which is 3
plus the heuristic value of c
which is zero
so this is going to be three
next let's calculate the cost of b
to e
now this is going to be again nothing
but the path value in this case 6
plus heuristic value in this case of e
which is 7
which is nothing but 13.
so again as you can see
this is the correct path to be taken
and we are not going to be taking this
part because its value is way too high
so the next path that we are going to be
taking is this path
b to c
so now we're at node c
from node c we can either go to a which
is not possible because we do not go
back in the direction that we came from
to b again
that's not what we're going to be doing
or to d
so the only option that we have
available is to go from c to d
right
so what we're going to do is we're going
to find the cost of going from c to d
again this is going to be the value of
the path
which is 9 plus the heuristic value of d
which is
4.
the cost of traversing this path is 13
but we don't have any other
path available to us because this path
has already been closed you can't
backtrack in a star algorithm or go back
to the path where you came from
and
again we've already considered a to c
before right
like over here
we've already considered a to c and
we've already ruled it out so again this
is not a part that you can take
so what we're going to be doing right
now is that we're going to be traversing
from c to d
and the cost of taking this path is
13.
so now
this is the path that we're taking from
c to d
where d now
at d again we can't go back to this path
we can't go back to c the only way we
can go is e
so we're gonna consider f of
d
to e
and this is gonna be again the path that
you're gonna take from d to e which is
five
plus the heuristic value of e which is
seven
this whole thing is going to be 12.
now once we're at c
our easter algorithm is going to check
if this is the target node
and lo and behold it is
so we've traversed from a to e
let's see the path we've taken
first
the starting node that we started off
from was a
from there we looked at the cost of
taking a to c a to e and a to b and
finally we settled for going from a to b
from b
again we consider the paths b to e and b
to c
we cannot consider a to b because this
path has already been travelled on and
it's already been considered before
now after considering b to e and b to c
we found that b
to c was the shortest path
from c we didn't have any other option
we couldn't backtrack or go back to b
and we couldn't go to a because this
path was already been considered and
already it has been ruled out so the
only path we could take from here was to
d
and again from d the only path that we
could take was to e so now let's look at
the path that we've taken while using
our acer algorithm
we started off at the node a
this was a starting node
from node a we had three options we
could go to node b
to node e or to node c
after considering all of these options
we realized that a to b was the path of
least cost that we could take once at b
we considered two parts b to e and b to
c
and we found out that b to c was the
path of least cost
from c
there was no other path we could take we
cannot go back to the node we came from
which is b
because a star algorithm does not
support backtracking and we couldn't go
back to a either because this path had
already been considered and we'd already
ruled this path out right
so the only path we could take was to
d
now once we arrived at node d
the only node that we could travel to
again was
e
so using a star algorithm this is the
final
path that we've taken to traverse from a
start node a to a target node e
and with the help of this case study
we've also explained to you exactly how
the a-star algorithm works
we use the path values and the heuristic
values to find the cost of taking
different paths available to us at each
node
and then we take the path which has the
least cost among all available parts
the same process will continue until
we've reached the final target node and
again remember you cannot go back on the
path that you came from or you cannot
go on a path which has already been
considered
so now you know how the a star algorithm
works
but what is the flowchart of the a star
algorithm
now a flow chart is a picture of the
separate steps of a process in a
sequential order
it's basically a generic tool that can
be adapted for a wide variety of
purposes and you can use it to describe
various processes
in this case this is the basic flowchart
of the a-star algorithm
it tells the direction of
control flow
within the a-star program and using this
you can implement a star algorithm in
any desired language of your choice
so the first step of our a-star
algorithm is to initialize the start
node and put it in an open list
now in this algorithm we're gonna first
create two lists an open list and a
closed list
the open list will contain all the nodes
that have been visited but the neighbors
have yet not been explored
on the other hand the closed list
contains nodes that along with their
neighbors have already been visited
so the first node or our starting node
is going to be put in an open list
because we're still exploring it
then we're gonna calculate the cost
function of the starting node
from here onwards we're gonna remove
this node from the open list and put it
in the closed list since we've already
visited it and calculated its cost
function
if we're also looking
at the neighbors which are surrounding
this node or if this node has many
different nodes around it then we're
going to calculate the cost function for
those nodes too
and save the index of the node which has
the smallest cost function f
next we're gonna look at if the node
we're currently on
is a final node or a target node
if that's the case we're gonna terminate
the algorithm and use pointers of all of
our nodes to get the desired path
if that's not the case then we're gonna
look at the successive nodes of n or all
the nodes which come after this node
which are not in the closed list
we're going to calculate the cost
function of each of these neighboring
nodes
remove them from the open list
as they're not already in the closed
list so they're obviously going to be in
the open list so we're going to remove
them from the open list and then we're
going to put them in the closed list
and again we're going to save the index
of the neighboring node with the
smallest cost function
and then this process is going to keep
repeating over and over until we've
reached the target node which is where
our program will get terminated
so basically what we're doing is we're
going to a certain node
calculating the cost function for that
node
looking at all the successive
neighboring nodes of it and going to the
neighbor which has the least cost
function
now this process will again get repeated
so from this neighboring node we're
going to find all the other nodes which
are connected to it
and then we are going to go to the node
which has the least cost function
so using this we're gonna hop from one
node to another depending on which node
has the lowest cost function
once this is over we're gonna again take
some other node and we're gonna repeat
this process until we found all the
possible parts to a final destination
node
and in this way the a star algorithm is
not only going to find the shortest path
but it's also going to find all possible
paths
now let's see how the a star algorithm
can be implemented with the help of
python
in this demo we will use the asr
algorithm to find the least cost path
between various nodes in the weighted
graph which is shown below
so in this graph as you can see we have
six different nodes a b c
d e and g
the weights of the paths between these
notes is denoted by these numbers in
black and the heuristic values of the
nodes itself are denoted by the numbers
in red
now using these values we can find the
shortest distance between any two nodes
let's see how we can do this with the
help of python
so now let's start by creating a class
for the a star algorithm
called the a star algo
now in this algorithm we're gonna have
to describe the open and the closed list
and to do this we're gonna be using two
sets
so our sets are our open list and a
closed list
we'll also be using two dictionaries
one to store distance from the starting
node
and another for parent nodes
and we're gonna start by initializing to
them to zero
the open set is gonna have the start
node already in it
now
we all know that the distance of the
starting node from itself is zero itself
so we're gonna initialize the distance
of the start node to zero
and we also know that the start node is
the root node and it has no parent nodes
so the start node is its own parent node
the first step of initializations is to
put the start node in the closed set
to set the distance of the start node to
itself as zero
and to set
the start node as its own parent node
now that we're done with the first
couple of initializations
let's move on
to finding all the neighboring nodes
so now we're going to have to find the
neighboring nodes with the lowest value
of the cost function
we also have to code for the condition
of reaching the destination node
if this is not the case we're gonna have
to put the current nodes in the open
list and if they're not already in it
then we're gonna set the parent nodes
so that's what we're gonna do first
we're gonna find the node with the
lowest cost function
we're gonna take the entire open set
and while the length of it is greater
than zero or basically well we're not at
the parent node
we're gonna loop through it
we're gonna go to all the
neighboring nodes of the open node
and then we're gonna find their
cost function
now here this is the function that
you're going to use to find the cost
function
now here what we're going to do is we're
going to calculate the heuristic value
for n
and
if the cost function of n is 0
or if its cost function is less than the
cost function of its neighboring node
then we're gonna go we're going to move
on to the next node which is v
now if n is equal to the stop node or
we've looped back and come to n itself
then we're not gonna go ahead
or we're gonna exit this loop
and we're gonna move on to some other
node
otherwise if the neighbor has a lower g
value than the current node and is in
the closed list we're going to replace
this new node as the neighbor's parent
and that's what we're doing here exactly
now if the neighbor is not in both the
lists then we're going to add it to the
open list and set its g value
and that's basically what's going on
here
so let's run this for the a star
algorithm
now we're gonna
define a function to get the different
neighbors and their distances
next we're going to create a function to
store the heuristic values and retrieve
them as and when required
now we're going to describe our graph
here
so these are all of our nodes and the
nodes that they're connected to along
with the weight of their paths so here a
is connected to b and the weight of this
path is 2
is also connected to e and the weight of
this path is 3.
in the same way
b is connected to c and the path has a
weight of 1 and g b is also connected to
g and the path has a
weight of nine
so here this is what we're going to do
to describe our entire uh
weighted graph
and then we're gonna finally call our a
star algorithm and give our starting
node and our final node
and
it very quickly finds the path between
our starting node and our final node
and over here as we can see the best
part to take would be from a to e
to d and finally to g
and that brings us to the end of this
video on the a-star algorithm
we hope that this video was useful to
you and that you not only learned
a star algorithm in depth but also how
to implement it in python
and we also hope that you enjoyed this
video if you did a thumbs up would be
really appreciated
also here's your reminder to subscribe
to our channel and click on the bell
icon for more on the latest technologies
and trends thank you for watching and
stay tuned for more from simplyla
hi there if you like this video
subscribe to the simply learn youtube
channel and click here to watch similar
videos to nerd up and get certified
click here