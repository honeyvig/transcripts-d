change is an inevitable aspect of
Technology where skill sets and job
roles continuously evolve and even
become outdated at times in order to
thrive in this ever-evolving IIT
industry professionals must remain
abrush of emerging Trends and
technological shifts continuously in
today's data driven world where the
volume and complexity of information are
constantly expanding organizations are
seeking powerful and flexible solutions
to handle the data management needs
MySQL posture SQL and Microsoft resql
server have long been the backbone of
data storage for decades to store and
manipulate data in relational databases
and there's no sign of them disappearing
anytime soon but with the world
undergoing a revolution driven by Big
Data and the high cost of SQL Solutions
make them impractical for addressing the
ever-changing demands of businesses with
the majority of data being unstructured
traditional relational databases are
unable to efficiently handle this
requirement of data management on large
scale consequently companies are
recognizing the necessity of adopting
alternative nosql databases like mongodb
mongodb goes a step further by
leveraging the benefits of cloud
infrastructure through horizontal
scalability and empowers users to
seamlessly handle large data sets while
enjoying the flexibility of mongodb's
data model by utilizing mongodb
organizations can develop operational
applications that drive business
engagement at a fraction of cost
compared to rdbms and according to a
dice report the number of no SQL jobs
for people experience with unstructured
database systems like mongodb coach DB
Cassandra has increased by 54 over last
year and major Tech gains like Google
Amazon Twitter FB and various other
industry leaders have already embraced
nosql databases on a large scale so what
could be better than staying out of the
curve and getting trained in mongodb
well subscribing to Simply learn of
course since we published decorated
content every day to help you master
various emerging Technologies and
programming languages and also make sure
to hit that Bell icon to never miss an
update from us today's video will be a
mongodb basic source for beginners we
will start off this video with a quick
introduction to noise scale databases by
understanding the fundamentals of
mongodb databases to become an expert in
mongodb firstly you have to understand
and master the concepts of schema design
and data modeling following the master
of data modeling the next step is to
master how to query Cloud operation and
perform projection on documents
furthermore it is important to
understand the aggregation framework and
how and when to use indexing with the
foundation in place one can progress to
intermediate topics such as monitoring
backup and restore Security Options as
well as understanding the various
storage engines that mongodb supports
and how to use mongodb with big data as
well all of this information should
provide a solid foundation for moving on
to Concepts like mapreduce grid fs and
scaling aspects such as replication and
sharding with the goal of providing
effective fault tolerance and high
availability now with it having said if
you want to upskill yourself with nosql
databases and become proficient in
mongodb then our post-agit program in
data analytics and partnership with
Purdue University and in collaboration
with IBM can help you with that this
course features master classes and
follows an applied learning model
designed with real life projects and
business case studies that will help you
boost your career so what are you
waiting for enroll now and take
advantage of this amazing opportunity
link is added in the description box
below so without any further Ado let's
get started over to our training experts
we'll be discussing what is mongodb why
is it used and what is its significance
into today's world I hope my audio is
fine and the screen is clearly visible
if you guys are facing any issue do let
us know in the comment section and our
team will try to fix it as soon as
possible all right now in the world of
databases the most common and well
popular databases are rdbms which is
relational database Management Systems
now what if you want to develop an
application which deals with the large
volumes of data then we need to choose
one such database which always provides
a high performance data storage
solutions so that we can achieve the
performance in the solution in the terms
of data store and the retrieval with
accuracy speed and reliability now if
you categorize the database Solutions
then there are many two types of
database categories that are available
that is the first one is rdbms like
MySQL SQL Server Oracle Etc and another
type is nosql databases like mongodb
Cosmo DB Cassandra Hadoop Etc more on
that soon firstly let us discuss the
agenda for today's session we'll start
the tutorial with a quick introduction
to nosql and then we'll discuss what
exactly is what is mongodb and then
we'll go through the history of mongodb
which is when it when and how it came
into existence and after that we'll
understand why we use mongodb up next
we'll discuss some key Salient features
of mongodb up next we will discuss how
exactly mongodb works and then we'll go
through some different applications of
mongodb in real life and then we'll see
which companies are using mongodb in
current days and finally we'll
understand when to use and when not to
use the mongodb
now before we understand what is mongodb
isn't it is important to learn what is
nosql now under the vast roof of Big
Data there lies a number of databases
which are used to store these massive
amounts of data that is generated
worldwide now one among them which is
attracting a huge number of interest is
the nosql database the not only SQL or
nosql database which is often referred
as with these two terms is an approach
that works towards managing data as well
as that database design which may come
in handy for huge sets of distributed
data it consists of number of
Technologies and architectures that seek
a solution to the Big Data performance
issues and scalability that cannot be
addressed by the relational databases
now this database is used when companies
and Enterprises develop a need to access
and analyze large amounts of
unstructured data or the data stored in
multiple virtual servers in the cloud
now there is no specific definition for
what nosql is but it is a common set of
observation where we can describe that
it is not a relational model that is
unlike the traditional relational
databases which store data in the form
of tables which comprises of rows and
columns no SQL database doesn't store in
that way now in nosql databases also we
have a various types of databases now
the first one is key value database that
is it is a simplest type of nosql
database and every data element in the
database is stored as a key value pair
consisting of an attribute name or key
and a value so in a sense a key value
stored is like a relational database
with only two columns the key or
attribute name such as anything like
state ID or name and the values such as
let's say a country name India so that
is one of a nosql database and next we
have column based or column oriented
databases now while a relational
database stores data in rows and reads
data row by row a column source is
organized as a set of columns this means
that when you want to run analytics on a
small number of columns you can read
those columns directly without consuming
memory with The Unwanted data
and of course we have the document type
of database the concept that is focused
on in document databases the documents
that are stored and received from the
database store can be like a Json or a
Json or an XML format now these
documents are usually similar to each
other and are in a hierarchical free
data structure that are self-describing
and consists of scalar values Maps
Collections and Etc
and finally we do have graph databases
guys now a graph database focuses on the
relationship between data elements now
each data element is stored as a node
and the connections between elements are
called links or relationships in a graph
database connections of first class
elements of the database taught directly
now in relational databases linked links
are implied using data to express the
relationship now these were some of the
mainly used nosql database guys but in
this tutorial we'll be only focusing on
the document database and which is one
of the most commonly used no SQL
databases out there and the best example
is mongodb and apart from mongodb we do
have other document databases like couch
base nosql database as well now that
we've understood what is a nosql
databases Let Us Now quickly understand
what is mongodb
mongodb is an open source document
oriented or a non-relational database
now it is different than traditional
relational databases like post to SQL
MySQL or SQL Server because it stores
the data in json-like documents instead
of tables and it is primarily is used to
store large volumes of data in the form
of documents
now traditional relational databases
stored data using tables and rows right
mongodb on the other hand is a
non-relational database which uh has
collections instead of tables now
documents are stored inside the
collections in where rows are
storing tables in traditional relational
databases now with mongodb the biggest
Advantage is the structure and scheme of
your data is flexible and not enforced
by a predefined table definition unlike
relational databases where you have to
specify the schema that is the structure
of the table the attributes and the
values in it now documents can vary
greatly in size and shape within the
same collection whereas tables are more
rigidly defined in a relational database
so when you are using mongodb it
represents hierarchy relationship in a
single record instead of joining
multiple tables so that is the main
difference between a relational database
and a non-relational database and
mongodb being a nosql database follows
the document data model which is a
collection of complex documents which
arbitrary nested data formats and
varying records formats now because
mongodb does not store data in a
structure table format you cannot query
it using SQL instead mongodb uses a more
flexible and a dynamic query language
called specific carries which is
based on JavaScript which we'll be
discussing in a certain way
all right I hope you understood uh what
is mongodb let us now go to the history
of mongodb guys now it is also important
that when and how mongodbs came into
existence even though we have several
relational databases in the market
now mongodb was first introduced in 2007
tangent software company began
developing mongodb in 2007 as a
component of a planned platform as a
service product so from 2000 to 7 to
2008 it was developed and it was working
as a platform as a service product
now in 2009 the company shifted to an
open source development model with a
company offering commercial support and
other services so from 2009 since it
became an open source the users can
directly download it from the internet
in 2013 tangent changed its name to
mongodb Inc and it is working under the
same Banner on October 20 2017 mongodb
became a publicly listed traded company
on NASDAQ as amdb with an IPO price of
24 dollars per share now mongodb is a
global company with U.S headquarters in
New York City and international
headquarters in Dublin and has more than
110 million download and regular users
in the current times and the latest
version of it was released in 2022 which
is 6.0
let us now understand why mongodb is
used guys now since mongodb is a nosql
database we need to understand when and
why we need to use it uh in real life as
well now since the normal circumstances
mongodb always preferred by the
developers when our main concern is to
deal with larger huge volumes of data
with a high performance so if you want
to insert thousands of thousands of
Records in a second then mongodb is the
best choice for that now also one of the
main reason is to overcome the
limitation of relational databases or
like the structured query language guys
where the language is only used for
certain
databases offer limited records right so
in order to overcome that we use mongodb
since it is a robust and highly scalable
and it is also powerful way of storing
data in comparison to traditional
databases
now it is also highly flexible which
allows you to store and work on
different data types in one document
whereas in relational database you store
data in tables and you have to maintain
a proper schema for that so you need to
join multiple tables if you want to
retrieve certain amounts of data and
mongodb also provides a lot of security
and it is also considered as a powerful
query language as well
now as discussed earlier mongodb allows
the user with flexible schema that means
it allows you to meet the ever-changing
conditions characteristics of Big Data
applications if you are working on
massive amounts of data on a regular
basis and also it gives you high
performance with its incredible features
like on-demand scaling real-time
resources which will guarantee the user
high performance of the applications let
us now discuss some of the key features
of mongodb now the first one is
aggregation now you might have heard
about aggregation in SQL as well now
data records are processed by
aggregation which is grouping of data
which then produces the competed results
or into a single result now in simple
words aggregation operations group
values from multiple documents uh in
mongodb database together and can
perform a variety of operations on the
grouped data to return a single result I
said earlier it is similar to that of
SQL Group by Clause where we use
aggregation functions like average sum
minimum Max I and others
next we have the grid FS now grid FS is
a specification for storing and
retrieving files that exceed the based
on document size limit of 16 MB now
instead of storing a file in a single
document grid FS divides a file into
parts or which is called as chunks and
stores each of those chunks as a
separate document Now by default grid FS
limits trans size to 255 KV now it uses
two collections to store files so it is
also another important feature of
mongodb now next we have sharding now in
mongodb uh it uses sharding and
replication which are another key
factors sharding allows partitioning of
data across multiple servers using the
shared key and the technique of
synchronizing all these organized data
across many servers to offer redundancy
is known as replication now next we have
document oriented as we all know that
mongodb is a document oriented type of a
database there are different documents
to store different types of data and
each document has a unique system
generated key the application I think we
have already discussed and also our
mongodb is a schema-less database that
is it stores data in collections with no
enforced schema so in other words
incoming data can have a predefined
structure and it can add to it however
different documents in the same
collection can have different structures
if required indexing is also another key
feature of mongodb which is one of the
most important options to improve the
search query performance now as a result
we should index the fields that fit our
search criteria like without indexing
mongodb it has to scan every document of
the collection to get the required
result that matches the query statement
right so in order to eliminate that we
need to provide indexing for a faster
query retrieval
next we have ADD our queries now in most
cases while designing a database schema
we don't know what queries we'll run
ahead of time right so when we design
our database we may not be knowing uh
the query types of the data that we
process into our database so ad hoc
query is the query not known while
structuring the data or you can say that
other queries are short-lived queries
whose value depends on variables so
mongodb supports these types of queries
and can we also updated in real time and
finally high performance performance
means writing speed performance of
mongodb is far greater than any other
relational database like MySQL those
were some of the key features of mongodb
so let us now understand how exactly
mongodb Works guys mongodb stores data
objects in collections and documents
instead of the traditional tables and
rows which is used in relational
databases now collections comprise sets
of documents which are equivalent to
tables and relational database now
documents consist of a key value pair
which are basic unit of data in mongodb
now the structure of a document can be
changed by simply adding a new fields or
deleting existing ones now documents can
define a primary key as a unique
identifier and values can be of variety
of data types including the other
documents and the array of documents so
it is basically uh works on a JavaScript
query which is Json
and it is for further classified into
base one which is a binary encoded
object notation so if you look at the
picture in this we have basically a host
which uh
ultimately has a server which stores the
data and further we have databases
wherein we have different Collections
and in collections we have documents so
the data is stored in this documents
which is further presented into the
collections and are saved into databases
so this is roughly how exactly mongodb
works let us now discuss some
applications of mongodb in real life as
well guys now one of the main
application is iot or Internet of things
which is one of the most appreciated
technology Innovations in the world
today connecting billions of devices
globally now with iot companies improved
productivity redefine their models and
leverage operational efficiency so
mongodb helps to maximize this full
potential of iot devices its intelligent
data platform which speeds up the
operation and delivery of iot devices it
is also extensively used in mobile
applications because with the data that
is being generated like for example in
social media in Internet we need mongodb
to handle such amounts of our data right
so it is also used in real-time analysis
now with rdbms databases analytics and
transactional databases were usually
separate and data from the transactional
database would have to be moved to
analytics and one environment which
requires an immense daily data load now
with nosql databases like mongodb
companies can now analyze data in real
time while saving cost for example if
you take stock market we have a tons or
trillions amounts of data has been
generated every day so again in sports
as well which is a real-time data
analysis to get the Insight we need the
data in a quick and faster manner so in
that case we can use mongodb as well
mongodb is also perfect for catalog
management content management as well as
product data management guys it enables
product data or the content related
information to be managed and processed
in a single Central system this allows
for detailed cost and analysis increase
productivity gain new insights and
improve collaboration with the companies
as well so one of the best example if I
take is the other card guys it is a real
world mongodb use case where other is a
India's unique identification project
and world's most extensive biometric
database system now we know that it was
I think it was launched into early 2010s
and it has collected demographic and
biometric information of over 1.5
billion people in India so other mostly
relies on mongodb among other databases
like hbase MySQL Hadoop which basically
runs on massive amounts of data which
process huge amount of data in a real
time
so mongodb was one of their database
systems first purchase to power the
search strategy of other card all right
let us now discuss some of the companies
which are using mongodb in real life uh
yes so companies like Google Facebook
Bosch eBay are some of the companies
which have extensively used mongodb
nowadays and apart from that we have
other companies like you know Toyota
Cisco Adobe essay Verizon and other
service and product based companies use
mongodb on a regular basis now apart
from this we have Shutterfly we have
MetLife we even have Forbes which use
mongodb on a regular basis
and that brings us to the end of today's
session guys now before we uh wrap up
the session it is also important that
you need to understand when you should
be using mongodb and when you shouldn't
now although mongodb is a great database
out there there are times you shouldn't
and you should use in certain uh
circumstances now mongodb works
extensively well with unstructured data
so it's great for uh big data analytic
systems so if you're working on huge
chunks of data which needs in a
real-time processing immediately then
you can use mongodb mongodb is also used
for cloud computing like Microsoft Azure
AWS which is an ideal cloud computing
platform uh for mongodb because
cloud-based storage needs to easily
distribute data across multiple servers
and which basically suits mongodbs
nature
now if you do not have any database
administrator in that case you you might
as well use mongodb as well now wherein
you have lots of unstructured data to
process and which has no storable data
type limits so in that case you can use
mongodb and finally if you have schema
issues that is if you have an unstable
or undefined schema you can use mongodb
which is not with the case of
traditional database which requires a
predefined schema before you start
working on the database as you all know
we are living in the era of Big Data
where massive volumes of data are
generated per second worldwide so
handling and storing these huge chunks
of data is pivotal are Paramount for all
the companies around the world
traditionally relational databases were
used to store this data prior to when
the internet came into existence now in
the early 1990s the internet gained
extreme popularity and the relational
databases could not keep up with flow of
information and data demanded by the
users as well as the large variety of
data types that occurred from this
Evolution this led to the development of
non-relational databases often referred
to as no SQL the not only SQL or
commonly known as nosql databases is an
approach to data management and database
design that may be useful for large sets
of distributed data and unstructured
data it basically consists of collection
of Technologies and architecture that
seek to address Big Data performance and
scalability issues that relational
databases cannot address so this
database is used when businesses and
Enterprises require access to an
analysis of large amounts of
unstructured data now these unstructured
data can be of any type it can be a text
file it can be an image or video and
others that are stored across multiple
servers so it is important that we
understand how this nosql databases work
so in today's session we'll be going
through all the concepts that are needed
to understand what nosql databases are
and how it they exactly work so without
any further delay let us jump straight
into today's topic
firstly let us go to the agenda for
today's session we'll start the tutorial
by understanding what is SQL and then
we'll look at why we use SQL and after
that we'll understand what is nosql
database and then we'll understand why
we use nosql up next we'll understand
how to use nosql and how exactly it
works and then we'll look at some
different types of noise scale databases
and after that we'll have a detailed
comparison between SQL and osql database
and finally we'll conclude the session
by understanding some advantages and
disadvantages of using nosql and will
also look when to use SQL as well as
nosql so without any further delay let's
dive straight into today's topic on SQL
versus nosql firstly let us understand
what is SQL SQL as it stand is defined
as structure query language is basically
a standardized programming language that
is used to manage databases and it
performs various operations on data in
them initially created in 1970s SQL is
widely used by many companies and
Technologies nowadays
SQL is used for modifying database
tables and index structures it is also
used in adding updating and deleting
rows of data it is also used to retrieve
subsets of information from within the
database management system
now SQL is used to perform various
actions such as to insert data to update
data modify and delete the data in the
database as well
now when we talk about SQL it is
important that we talk about relational
database systems as well a relational
database system or RDM rdbms is a
database system that stores and fixes
data in the form of table that is in the
form of rows and columns tables are used
to store data in relational databases
about related objects each column
contains attributes of data whereas each
row holds a record of unique data known
as a key which helps in making
relationship between different data
points that is present in different
table which makes us easy to understand
now these relational databases or rdbms
are managed using SQL language
to perform various operations therefore
SQL codes are used to retrieve
information from these relational
databases by doing various interactive
operations like using join create
truncate delete alter and Etc
let us now look at some popular SQL
databases some popular SQL databases
that are available are MySQL Oracle
database Microsoft SQL
server sqlite and postgresql
now that we have understood what is SQL
let us now understand what is non SQL
that is no SQL sorry no SQL database is
a non-relational database management
system that does not require a fixed
schema that is the data is stored is not
stored in the form of tables and nosql
databases
basically it avoids any uh joining or
creating or scaling the databases in SQL
the major purpose of using a nosql
database is for distributed data storage
which is having high volumes of data
storage needs noise scale is used for
big data and real-time web applications
like for example companies like Amazon
Facebook Google correct terabytes of
users data and every single day
so basically nosql database stands for
not only SQL or not SQL and it is
introduced in the year 1998 by Karl
Strauss now traditional rdbms uses SQL
syntax to store and retrieve data for
further insights now instead our nosql
database system encompasses a wide range
of database technologies that can store
structured semi-structured as well as
unstructured data
let us now understand why we use nosql
we use
hierarchical storage structure instead
of a table like structure
that means before relational databases
companies used a hierarchical database
system which with a tree-like structure
for database tables now these early
database Management Systems enable users
to organize large quantities of data
however they were complex often required
a particular application and in a
limited way which they could uncover the
data that is stored now these
limitations eventually led to the
development of relational database that
is the data that is stored in tables so
a skill provided an interface to
interact with relational data and
allowing the analysts to connect Tables
by merging on common fields But as time
passed the demand for faster and more
desperate usage of larger data sets
became increasingly more important for
emerging Technologies for e-commerce and
other big giants for that nosql has
become the alternative for everyone
now another reason is it is now we have
constant addition of new features and
functions in the nosql database right
so that means like we know that
technology is being rapidly evolved and
uh huge enormous amounts of data has
been released on a daily basis and it's
important that we store this data and
access in a quick way now nosql is the
best database to use for large amounts
of data or for Ever Ever Changing data
sets it is also best use when you have
to have flexible data model or need that
don't fit into a relational model
and finally then if if you want that
there is no relationship between any
stored data and the field is not
important then you can use nosql as well
let us now look at some popular noise
scale databases some popular nosql
databases are mongodb Apache hbase
Cassandra redis neo4j and Etc
let us now look at some types of nosql
databases that are present firstly we
have document oriented the document
database typically stores
self-describing Json XML and piece on
documents they are similar to key value
stores but in this case a value is a
single document that stores all the data
to related to a specific key popular
fields in a document can be indexed to
provide faster retrieval without knowing
the key as well each document can have
same or different data structure
mongodb couchdb cloudant are some
examples of document based uh nosql
database next we have key value pair
database the data in this is stored like
a key value pairs key value pair data
stored in database in the form of a hash
table each key is unique in this case
the value stored may be an integer
string a binary object a Json object Etc
the key Value Store based database is
simplest database among all the data
databases in nosql database
redis coherents are examples of some key
Value Store databases
next we have column based or column
store database in nosql which is in this
the data stored in grouped columns
instead of rows every column values are
stored separately it delivers high
performance on aggregate functions like
count sum Max minimum group of columns
are data stored in key spaces like
schema and rdbms key spaces contains
group of rows or columns
and hbase bigtable aquilmo are some
examples of column store databases
and finally we have graph oriented or
graph store databases data in this is
represented in the form of a directed
graph it consists of notes and edges
nodes represent an entity and any Edge
represents the relation between the two
nodes node H to be unique social
networks Logistics paytl data used uh
graphical storage database neo4j
infinite graph Orient DB flock DB are
examples of some graph storage database
next let us understand how exactly nosql
database works for that I am going to
take the example of mongodb database now
mongodb is based on the nosql document
store model in which data objects has
stored as separate documents inside a
collection instead of a traditional
column and row of a relational database
now uh mongodb groups data through
Collections and basically a collection
is simply a grouping of documents that
have a SIM or similar purpose a
collection acts similarly to a table in
a traditional SQL database however it
has a major difference a collection is
not enforced by a strict schema that is
it does not have any fixed schema at all
instead documents in a collection can
have slightly different structure from
another as needed this reduces the need
to break items in a document into
several different tables at as it is
often done in an SQL implementation now
coming to document a document is a
representation of a single entity of a
data in mongodb database a collection
consists of one or more related objects
major difference that exist between
mongodb and SQL is that in that
documents are different from rows row
data is flat with one column for each
value in the row however in mongodb
documents can contain embedded
sub-documents providing a much closer
inherent data model for your
applications now if I just have to map
what uh what are exactly and how it is
different from rdbms a collection in a
mongodb is equivalent to the tables in
rdbms and a document in mongodb is
equivalent to the rows in rdbms and
Fields in mongodb is equivalent to the
columns in rdbms
so this is how a document looks uh in a
mongodb as you can see this is similar
to a row in rdbms but we just have a
field and a value that is taken
separately in instead of a tape tabular
value
and another important thing to note note
here is that a mongodb supports Dynamic
schema which means one document of a
collection can have a number of fields
while the other document can have less
or same number of fields that is if a
collection can have four Fields while
other document can have only just two
fields which is basically not possible
in a relational database which does not
exist uh as it it does not support
because it needs a particular and a
fixed schema in that
let us now understand some differences
between the SQL and nosql firstly SQL is
a relational database and nosql is a
non-relational database that means SQL
databases are in the form of tables that
can contain rows and columns and they
have fixed logical schema design all the
data in SQL is arranged in tabular
format and it is well suited for complex
queries and on the other hand nosql
databases is a non-relational database
that means it does not store data in the
form of tables and contains Collections
and inside every collection there is a
document that contains the data of a
single entry we store this data is
stored in the form of a key value pair
unlike SQL where we store data under the
fixed schema
so as we discussed uh SQL has a fixed
schema design and structure and nosql
has a dynamic schema design and
structure
SQL can handle complex queries whereas
no SQL can handle large volumes of data
now SQL is vertically scalable
now uh SQL databases support vertical
scaling which means it improves the
single server by increasing Ram SSD or
CPU in vertical scaling we are
restricted to a single system and we can
improve it as much as we want till the
Practical limit whereas a nosql database
we can do horizontal scaling because
they support distributed computing or
distributed systems in horizontal
scaling we can add another node or
computer for better performance and we
can add a number of such servers or
nodes as per a requirement so as
discussed we can add as many as nodes as
we want and this is why we prefer nosql
for high scalability because there is no
limit for scaling
and finally it follows acid properties
that is atomicity that means transaction
should be performed at once or it
shouldn't happen at all consistency that
means the state of a database should
remain consistent before and after the
transaction isolation that is one
traction one transaction shouldn't
affect another transaction and it
shouldn't and should be independent and
we lastly durability now successful
transaction should be reflected even if
there is any system failure whereas the
noise skill follows cap property
that is consistency availability and
partial tolerance
let us now discuss some advantages and
disadvantages of using nosql firstly let
us discuss about the advantages
nosql provides high performance and
scalability and it also has a lot of
availability and flexibility it is open
source and it is schema less as well
that is you can directly uh download the
nosql databases from the internet unlike
some commercial databases that are
available in the internet
while on the other hand there are some
disadvantages as well that is it is it
lacks the standardization that means it
does not have a fixed query in order to
retrieve data from the databases which
result in in consistency issues and
since it has all these consistency
issues and does not retrieve data
properly it it has a limited query
capabilities
thank you
so that brings us to the end of today's
session on SQL versus noise scale guys
so you might have a doubt that when you
need to use SQL and when we need to use
nosql now SQL is easiest to work with
relational databases that is it is
useful when you want to perform complex
queries using various operations like
join and Etc and if you want to perform
quick data storage and retrieval
operations you can use SQL whereas uh if
you want you can use nosql if you are
designing a distributed systems and if
you want a hierarchical storage
structure instead of a tabular like
structure also nosql gives you the
flexibility to create Dynamic structures
and and can add features as you as you
want
also there is no asset properties during
the creation of any applications while
creating a
nosql databases as well so in this way
you can use nosql and SQL as per your
requirement now since it's already
installed on my system uh the
installation process will be different
but you just need to follow the steps
there and finally install it so once
you're done with the installation you
can go to your C drive and here you can
click on program files and you can see
that mongodb is installed and inside of
it you have the server folder and then
you have the 4.4 folder and then you
have the bin folder right so here you
have the application that is your
and the mongod applications both are
executable files now the mongod file or
the application is the daemin process
now this is the background process that
makes sure you retrieve the data from
the database access the data so it does
all the background tasks so after the
installation now you need to create a
path to this file by doing this you
don't have to always go to the bin
folder and then execute the file you can
directly execute the file on your
command prompt right so for that let's
just
go to our environment variables
but before that let's just uh
copy this path
right
and here under the user variable section
click on path and say edit
and go ahead and just paste it right
I've already pasted mine so just go
ahead and paste it and click on OK
and
yeah
say okay
right so now you've created the path
successfully now let's head to our
Command Prompt and run the file so
here you can just directly type
since the path's already been created so
just go ahead and say
[Music]
and here you can see that your
server has been generated
and with this you know that you're in
mongodb has been successfully installed
and your server is up and running right
so just for confirmation let's see if
there are any databases and how much
space they've occupied so you can right
now just type show DBS
[Music]
and when you click on it it says admin
config and localhost and all of it is
zero so with that you have successfully
installed mongodb on your system and
it's up and running now in contrast to
structured query language or SQL
databases which is a relational database
model where the structure of the
database and its tables have been
defined mongodb does not have or
required the definition of a database or
a table structure instead we use data
models in order to store the documents
in our database so moving ahead let us
now first discuss the agenda for today's
session we'll start the tutorial by
understanding what is data modeling and
then we'll understand why we use data
modeling after that we'll be going
through how data modeling actually works
in mongodb and next we'll understand
different types of data models in
mongodb up next we'll discuss types of
relationships and data models and then
we'll see some methods to create these
data models and finally we'll understand
when to use these data models as per our
requirement so without any further delay
let's get started with today's topic all
right so what is data modeling in
mongodb now basically data modeling is a
process of taking unstructured data that
is generated from The Real World
scenario and introducing it to the data
server and then structuring it into a
logical data model in our database so it
is basically a process of determining
how data is stored and what connection
exists between various entities in a
relationship now you don't have to
create a schema before inserting data
because nosql is flexible this is so
that mongodb can support a dynamic
database schema that makes it
unnecessary to create your schema in
advance you instead you can now store
your information and make changes in
accordance with your data now consider
data modeling in mongodb as a
relationship now there is no particular
relationship just like a SQL where we
use Now mongodb relationships are the
representations of how multiple
documents are logically connected to
each other in mongodb now since mongodb
is a document database any document
within the same collection is not
mandatory to have same set of fields or
structure you can store different types
in the collections given field and can
even add new Fields update fields and
delete existing Fields as well now for
example consider an online shopping
store where we have like thousands of
customers arriving daily and purchasing
new products from the website now we get
a lot of unstructured data that is the
name of the customer the details and all
which is basically an unstructured data
now in order to convert into a proper
structured data we need to model them
into a particular weight which this is
where data modeling comes into a picture
where we store the data based upon our
requirement now the main challenge in
data modeling is balancing the
application needs guys now the database
engines performance characteristics and
also the data retrieving patterns
all right let us now move ahead and
understand why we use data modeling
now data model basically helps us to
create a simplified and optimized
logical database that eliminates
redundancy red is a storage requirements
and enables efficient retrieval from the
database now data modeling may appear to
be a complex process wherein you have to
make adjustments to your database unlike
SQL value predefine your schema and
create a new table and then store the
data now while in mongodb data modeling
helps us to analyze and understand what
type of data and how much data has to be
inserted into a database data modeling
is necessary foundational work that
allows data to be stored more easily in
the database and has a positive positive
impact on data analytics as well now let
us understand why exactly we use now
data modeling now data quality is
Paramount for any organization and to
ensure that we need higher data quality
when we are storing unstructured data in
large amounts now the visual
representation of requirements and the
business rules enables to anticipate
what could lead to a large-scale data
corruption before it occurs so data
model enables the developers in
hindsight to Define rules that monitor
the data quality and ensuring that there
is no possibility of errors
now it is also important to understand
how the data is Flowing within the
database and the characteristics of that
creating data models forces the business
to Define how data is generated and move
across the application development and
maintenance data modeling exposes errors
and inconsistencies early in the process
making is it making it easier and less
expensive to fix so in order to maintain
a database that is a mongodb database
which is basically a unstructured one it
is important that we try to develop and
maintain it in a regular basis
and finally performance is another
reason why we use data modeling now an
organized database is one that is more
efficiently operated and data modeling
prevents the schema from endless
searching and returns results more
quickly those were some of the reasons
on why we use data modeling is
all right let us now move and discuss
how data modeling Works in mongodb
now unlike SQL databases where you must
determine and declare a table schema
before inserting data or perform any
operations we need to basically provide
a schema for that now mongodb's
collection by default do not require the
documents to have the same schema now
the documents in a single collection do
not need to have the same set of fields
and the data type of for a field can
differ across documents within a
collection now to change the structure
of the document in a collection such as
adding a new field or removing the
existing field in a document or changing
a field values to a new type or update
the documents to the new structure
now basically the first step is to
basically create and design a schema as
per the requirement and the application
made by the user and then we have to
combine documents now if there is no
scope for multiple documents uh to store
into a single one and ensure that if
there is no other need for a single
document to store in a multiple document
in such way we need to understand what
is our requirement and combine the
documents accordingly so that we can
have performance as well as the
optimization of the database is also
improved now this flexibility
facilitates the mapping of documents to
an entity or an object now each document
can match the data field of a
represented ID entity even if the
document has substantial variation from
other documents in the collection so
this is how basically a data model Works
wherein you have to choose as per the
requirement and understand what type of
documents that are being inserted into
the database
all right let us now understand some
data models that are used in mongodb now
once you've understood the business
requirement and the application on how
it should be as you start modeling your
data you will likely go through various
steps of data analysis now each step
might produce different types of data
models therefore ensuring data models
having the right one can be generally
thought of as being one of the main
aspect of choosing a data model and they
are conceptualized into three categories
based on the level of the detail and the
specificity now that's classified into
three types the first one is conceptual
data model the conceptual data model
explains what the system should contain
with regard to and how it is related
this model is usually built with the
help of the user and the stakeholders it
represents the applications business
logic and is often used as the basis for
one or more following model
next we have the logical data model Now
The Logical data model will describe how
the data will be structured in this
model the relationship between the
entities is established at a high level
you'll also list the attributes for the
entities represented in this model
and finally we have the physical data
model guys the physical data model
represents how the data will be stored
in a specific database now in this case
we have mongodb model where we are using
establishing a primary and a secondary
relationship between the data in a
document that is stored in the database
such as mongodb you will also establish
the data types for each of your fields
that are mentioned this will provide you
with your database schema as well
foreign
mongodb has a flexible schema you need
to uh data model or schema design a good
data model means that you'll establish a
strong foundation for an Ever evolving
data model now mongodb supports multiple
ways to model relationship between the
entities in a data model now the first
one is one to one that is in this type
one value is associated with only one
document that is it will have a single
relationship between the two connected
objects or entities in the database next
we have one to many here one value can
be associated with more than one
document or value at the same time and
finally we have many too many now when
two or more entities within a document
can have multiple relationship that is
basically is many to many relationship
in this type of model multiple documents
can be associated with each other so let
us now quickly understand with an
example now consider the example for one
to one relationship where I have a
student table and contact info table now
for each student ID there is a unique
details or the contact info so it is
basically pointing one value to another
that is student ID which is one to one
relation and similarly we have one too
many relation wherein we have customer
table and Order stable now every
customer has a different ID and a
customer can place multiple orders so it
can generate multiple order IDs so we
have three different IDs like b204 b391
b448 so this is what is one two mini
which is basically one entity is being
pointed to three other values I hope you
understood one to one and one to many so
if you understood this let us know in
the comment section below what will be a
good example of many to many
relationship
all right moving ahead let us now
discuss the types of methods to create
the data models now once we are
confirmed with what data model we need
and the relationship that we have chosen
for uh for our documents to store the
data we need a method that is to create
a data model now that is where we have
two different data models that stores
the data in documents that is first one
is embedded data model so in emitted
data model you can embed data in a
single document or structure in mongodb
it is also referred to as the normalized
data model it leverages the full
potential of mongodbs Rich document and
it uses a one to one or one-to-many
relationship guys
next we have the reference data model or
in other words it is known as normalized
data model now they are used to build
one too many as well as many to many
relationship models now while working
with the embedded document models there
will be times when you have to repeat
the data this is where reference data
model comes into picture which basically
tackles their data redundancy
so I know it is bit of confusing so
let's just understand this with an
example here now if you consider the
embedded model if you look at a document
which I have taken here which is the
details of a student named Rohan where
we have a collection uh that is
containing a document has Rohan in this
document we have embedded a document
here that is contact details and his
grade
so embedding uh data model stores
relevant details in the same documents
or the same database record this way you
can minimize queries and update required
to perform common database operation on
the other hand we have a reference data
model or the normalized data model
so if you look at to the reference model
example here we have basically split the
single document into three documents and
since contact details and grade have the
ID from the document that is of rohans
you can call them whenever needed now
normalized data model splits the data
into multiple collections by using
references between the newer collections
you can update or change a single
document which will update other
collections automatically this is an
efficient way of updating data and is
mostly used when your data goes through
frequent changes that is if you're
working on a data that has to be
leveraged or changed on a daily basis
you can consider reference model
that is which is basically one of the
biggest advantages of using normalized
data where you have to model large data
sets that follow a certain hierarchy and
you have to where you have to represent
multiple many to many relationships so
that is where we use a embedded model
and reference model all right as we know
mongodb is a nosql database program that
controls document oriented data instead
of a relational data made irrational
data model which comprises of rows and
columns now the speed of mongodb is one
of its characteristics as it handles a
huge chunks of unstructured data so in
order to perform a certain operation
mongodb may use operators to carry out
particular tasks in order to return
queries more quickly and efficiently so
in today's session we'll be taking you
through all about the mongodb operators
what are the the different types of
mongodb operators that I use its
functions with the help of some examples
so without any further Ado let's get
started so what is mongodb operators
operators are basically special symbols
or keywords that tell a compiler what
mathematical or logical operations to
perform the operator improves mongodb
functionality by enabling the developers
and programmers to construct
sophisticated queries to communicate
with data sets that are appropriate for
their application and perform certain
complex tasks to retrieve the data now
in general we use the find command or
method to fetch the data from
collections using the query operator
also we need to use the prefix which is
the dollar sign before the query
operator so let us just quickly
understand the syntax of the operators
in mongodb the syntax is followed as DB
dot name of collection dot find and
within the parenthesis
we have to mention the field name and
mention the semicolon and then we have
to mention the dollar symbol with the
help of the operator that we want to use
mention the value and finally we use the
pretty uh method so let us just quickly
go through all this uh
terminology so that will have a better
idea now the name of the collection is
basically according to the query
operator we used in our query this
parameter is defined as the collection
name from which documents have been
retrieved next we have the find method
now data can be retrieved from
collections using this technique we can
also retrieve particular documents from
mongodb by using the find method with a
query operator next we have the field
name according the query parameter we
used in our query this parameter is
defined as the name of the field from
which we are retrieving data that is
what we are trying to uh retrieve data
from our collection is basically the
field name next we have the query
operator name which must be used to
retrieve the documents from the
collection in accordance with the query
operations next we have to mention the
value the value is nothing more than the
field value that we used with a query
operator to conduct logical or any
mathematical operations and so on and
finally we have an option well uh
tag which is pretty now since mongodb
output is generally is in an
unstructured format so we can display
our output using this technique in a
structure format and this is also
optional guys so if there is a
requirement to show the data in a proper
structure where you can use the pretty
uh statement so that was all about
mongodb operators guys so let us just
move ahead so let us now understand the
different types of operators in mongodb
now just like any operators in other
programming languages mongodb operators
are used to perform specific relational
mathematical or logical operations and
produce this final result operators in
mongodb are you know broadly classified
into three types the first one is query
and projection operator next we have
update operator and then finally we have
aggregation pipeline operator
now in mongodb the default for queries
is to return all the fields in the
matching documents so basically a query
and a projection operator is used to
perform certain calculation wherein a
projection query is used to specify or
restrict the data result returned in
query result Now by specifying a
projection query you can specify the
fields you want to return or exclude now
similarly we have other query operators
which we'll be discussing in a while
which are used to perform certain a
complex calculation on the data that
you're retrieving from the documents
next we have the update operator which
basically updates the value of all the
fields of the documents which is
matching the specified condition and
finally we have the aggregation pipeline
so it basically provides a competent
results as a result of processing the
data requires an document so it is
similar to that of aggregate functions
in SQL wherein it you know Aggregates
all the values within a document and
perform certain aggregation uh operation
like you know some Maximum minimum and
so on so these are some of the main uh
different types of operators in TV
so let us now just uh get into detail
and how that further classified into
various types now query and projection
operator further classified into various
other types such as comparison operator
logical operator array operator element
Operator bitwise Operator evaluation
operator and finally we have geospatial
operator now it is time taking to get
into all of this stuff and explain each
and every operator guys so let us just
focus on the main operators that are
frequently used in mongodb
so firstly let us discuss about the
comparison operator guys now the
comparison operators are basically used
to compare two expressions and retrieve
data from the documents that is the
documents that are that we have stored
uh that is the all the data from the
collections which are basically the
group of collections is basically a
document in mongodb that is stored in
the mongodb database now we have several
such comparison operators in mongodb now
as explained earlier we have to use the
dollar sign with the help of operator
that we have been uh mentioning so
basically The Operators uh take the
dollar sign and then we have to mention
the operator that we have taken so let
us just discuss some of the operators
here the first one is EQ which is
basically the equal operator which
matches values that are equal to the
values specified in the query next we
have dollar any which has a full form of
not equal to which is opposite of equal
and matches all the values that are not
equal to the value specified in the
query next we have GT and GT which is
basically greater than and greater than
equals to uh this operator basically
matches the value that are greater than
the value specified in the query or that
are even greater than or equal to the
various value is specified in the query
next we have the LT or LTE that is less
than or less than equals to again as the
uh the word course it is similar again
it matches the values that are less than
the value specified in the query or it
matches with the less than or equal
values specified in the query in the
document and finally we have the in and
nin which basically matches any of the
value that is existing or not existing
in an array specified in bigquery I know
it is a bit of confusing so let us just
uh understand this with an example here
so consider this example on your right
hand side where you can see this image
which is basically a format of a
document that is stored in a mongodb
database guys so let us say I have uh
you know a collection named orders of
let's say a stationary item database now
I have further different three different
documents that are present in
uh this collection so basically a group
of documents is basically a collection
in a mongodb database so I hope you've
understood uh what is a collection
document and what is a database so if
you want to know more about it we have a
dedicated video on what is momotb where
we've uh explained clearly on all these
terms and how it exactly Works make sure
you check that out uh which will be
quite helpful and I would highly
recommend so as you can see we have
basically three documents here we have a
ID of three different uh people who have
purchased certain products from a
stationary and have different IDs so we
have three customers here Rahul printer
and kirti now if I say if I want to
perform comparison operation for this uh
let us just understand how equal and not
equal operation performs so basically uh
I'm taking an example here which says
dp.orders DOT fine where payment mode is
equals to card so basically uh the
compiler finds all the documents that is
present in this college action where the
payment mode is made through card which
instead of cash so basically we have
here uh the details of two customers who
have used their payment models card
which is customer Rahul and customer
kirti so in this way it will return
these two following documents and
similarly we have any which is not equal
to and I'm taking another example which
is DB dot ordersfind order total is not
equal to 600. now as you can see in the
image we have the third document of
customer kirti whose order total is 600
right so it basically evaluates this and
Returns the result which has an order
total which is not equals to 600 that is
basically the first two documents that
is it will retrieve the data from this
document of the first uh you know two
documents which is of customer Rahul and
customer prenup whose order total is
basically 2450 and 5800 respectively so
that is basically what is a comparison
operator using EQ and any which is equal
to or not equals to All Right Moving
ahead let us now discuss what is GT and
GTA which basically derived is greater
than and greater than equals to again
let us consider the same uh you know
collection same example that we have
taken earlier now the first query is
basically a first GT that is DP dot
order find order total is greater than
three thousand all right so we are
basically performing a search query
wherein we want only uh those documents
whose order total is greater than three
thousand now if you look at the image we
have only uh I guess one document which
is of customer pranav whose order total
is 5800 which is more than 3000 and
similarly we have for greater than
equals to which is DB dot orders fine
order total GTE uh 2450. so basically we
should retrieve the document whose order
total is more than 250. again we have
two documents here right now we have a
document of customer Rahul and the
customer pranav whose order total is
2450 which is equals to 2450 for that we
have mentioned in our query so basically
uh the details of the documents of
customer Rahul and customer pranav whose
order total is greater than or equals to
24 500. all right moving ahead let us
now understand what is LT and LT which
is a negation or complete opposite is
greater than greater uh than equals to
now in less than we have taken an
example which is again order total Which
is less than 2000 uh so I guess we have
only one record again here of customer
kirti whose order total is 600 and
similarly less than or equals to 500 now
I guess we have only one document again
of kirti which is order total is 600. oh
I'm sorry are less than or equals to 500
right so we don't have any uh you know
document of the customers Which is less
than or equal to 500 guys sorry uh just
a pardon me for my mistake I didn't
check so we don't have any customers
whose order total is less than or equals
to 500 so it will basically uh you know
retrieve a null value
so that were some examples of comparison
Operator Let us move ahead with logical
operators now so basically logical
operators return data based on the
expression that evaluate the following
condition to either be true or false now
in general we have four different types
of logical operators in mongodb which is
and or not and not which is again
similar uh with any other programming
languages where we use a logical
operator and similar to that of SQL as
well now the basically the and operator
returns all the documents that match the
condition of both the expression
specified and or operator returns all
documents that match the condition of
either expression specified next we have
the nor operator which returns all
documents that do not match the
condition of either expression this is
basically an opposite of or operator and
finally we have the not operator which
basically returns documents that does
not match with the query expression in a
document so again let's just understand
with an example by considering the same
example which is the order collection
now for X first example I am taking and
operator which says DB dot orders fine
and address city is either daily or
payment mode is cash now if I look into
the uh collection here I have only one
such document where City address city is
Delhi and payment mode is cash that is
the details of customer pranav so it
will retrieve only the document of
pranav here next if I consider the r
operator which is DB dot orders fine or
CT Jaipur or order total is less than or
equals 200 so we have Jaipur uh City
whose uh I think it's of customer uh
Jaipur yeah it's of customer Rahul so it
will retrieve that one and it will also
retrieve those documents whose order
total is less than or equals two
thousand now we have only one document
of kirti whose order total is 600 which
is again less than or equals to 100 so
basically the first document and the
third document will be retrieved in our
query in a final resultant set and
finally we have the nor operator which
says this CT is either is not either
daily or payment mode is cash now other
than City Delhi and the payment mode
cash that is we have a pranav whose
payment mode is cash and also belongs to
Siri so basically it will remove the
document of this person customer
and it will fetch the first and third
documents that is uh the I the customer
rahul's and the customer kirti
so those were some of the uh logical
operator examples we have used I hope
you've understood
so moving ahead let us now discuss some
element operators guys the element query
operators are basically used to locate
document I know based uh on the fields
of the document
now what that I mean is so basically
every document has a field right now for
example let's say in the previous
example I've taken ID customer name
order total and so on and so which is
basically a field I know these field
have further values or elements to its
name right so the element operator
basically uh finds all the documents
based on the fields of the document that
you are trying to search for now we have
basically two uh element operator which
is exists and types exist operator
basically returns documents that have a
specific field now if I let let us take
an example let's say I have an uh you
know collection employees and I want to
find the employee age as a field I want
to find if there is a field called
employees and his age is greater than or
equals to 35 so I have taken this
example which is DB dot employees fine
employee age exists true gt35 so if
there is any field in our collection of
employees and this greater than 25 or
greater than 35 it will retrieve those
documents and similarly we have the type
document type operator which returns
document is field is of only a specific
type specified type now uh if I take an
example here let's say if I'm trying to
find a field uh employee age again and
it is of double uh double integer type
so if I want the particular you know
field data type I can use it type
operator here so this was that was all
about element operator guys and let us
move ahead and finally discuss one of
the main us operator that is array
operators array operators in mongodb are
basically used to query documents that
include a field of arrays now we
basically again have three different
types of operators used in mongodb
the first one is all operator it returns
documents from a collection if it
matches all the values in the specified
array next we have this size operator it
returns documents from The Collection to
match an array with a provided number of
elements in it next and finally we have
LM match which returns those documents
that match specified condition within
each array element now I hope I know it
is bit of confusing so let us just move
ahead and understand with an example
here consider the same uh example again
where we have three documents here now
for first example I have taken the all
operator which is an array operator so
what I'm trying to find is I am trying
to find a element of value which has you
know a notebook and a paper so the query
is followed as DB dot order dot find
orders item all notebook and paper so if
you look into the image I think we have
only uh two documents where we have this
Fields uh having notebook and a paper
that is the first customer and second
customer if you look into the item name
you have notebook and paper in the first
uh document and second document also we
have item name notebook and paper so it
will retrieve these two documents and
next we have this size so the size
basically retrieved the number of array
elements that you want in your resultant
set now the queries followed as DB dot
order DOT fine where order items is of
size 4. now if you look into three all
the three documents that are present
here we have only one such document
where it has four elements now if you
look at the first document of customer
Rahul order items we have four different
uh you know fields that is he has placed
an order on Notebook play Paper General
and postcard now in contrast if you look
at to the other two uh
documents where we have only notebook
paper and postcard for pranoff and we
have only notebook and postcard for
kirti so which is against or which does
not satisfy the size operator so it
basically retrieves only the first one
which has four elements or Fields so I
think that was all about the array
operators guys I hope you uh understood
about all the query and projection
operators and its different types now
again we have uh several many operators
like geospat DL uh comment operator and
so many but which are not that
significant in its usage but anyways if
you want us to cover uh in our further
tutorials let us know wherein will try
to cover a more uh you know detailed
version of it with a hands-on experience
with the mongodb database as well
and finally let us discuss uh what is
upgrade operator guys and basically
mongodb offers a variety of field update
operators to update the values of the
fields and documents matching the
specified condition so it is basically
similar to that of your DML command
which is an update command which is used
to used to update the values in the
columns now similarly in mongodb there
might be a possibility that you have to
update some values and that is where we
have the update field operators now
there are again various such of update
operators so let us just go in through
one by one we have first one as current
date which is used to set the value of a
field to current date either a date or a
timestamp next we have Inc which is
basically increment it is used to
increment the value of the field by the
specified amount next we have the Min
and Max which is used to update the
field if the specified value is less
than the existing field value or it is
greater than the existing field value
next we have the mul which is uh a full
form of multiply it is used to multiply
the value of the field by the specified
amount and finally we have the rename as
a name suggests this operator is used to
rename a field within a document
so that was all about the operators in
mongodb guys I think we have got most
almost all the important operators that
are used frequently on a general basis I
think these are quite enough for you to
perform all the complex operation that
you undertake or to retrieve certain uh
you know documents or values in your
database what are regular expressions in
mover DB regular expressions are used to
match specific patterns in a document it
is basically nothing but finding strings
within a document now it's possible that
you won't always know the precise field
value to search for when retrieving
documents from a collection so in order
to help with the data retrieval based on
search values that match up specific
pattern instead of the whole uh word or
a string regular Expressions can be used
it comes with multiple options also so
we can customize our query to check if a
field contains a string or not
now why we use regular Expressions now
there are many reasons but these are
some of the important uh factors on why
we use regular expression just like in
any other uh languages we use right so
even we discussed regular expressions in
SQL also in our previous tutorial so if
you haven't checked that out make sure
you uh check that out our channel on SQL
playlist now the first reason is obvious
that it provides patterns or a sequence
of characters for matching text and
Define search patterns now like I said
instead of searching the whole uh value
in a particular field you can just write
a simple pattern that you are aiming to
search for
now it retrieves any unidentified field
in a document easily as well and finally
it queries databases to find a smaller
subset of data within a collection so
instead of retrieving all the fields
again in a document you just you can
retrieve only a portion or a part of
data from that collection using regular
expressions
now this can be achieved with the help
of the regex operator now what is regex
operator the reex operator provides
regular expression capabilities for
pattern matching strings in the queries
so in in simpler terms using this
operator one can search for the given
string in a specific collection so if
the exact field values are known that a
user is looking for in the document this
operator can turn it handy let us now
understand the same types of the regets
operator now we have various different
types of syntax uh the first one is a
generic syntax where we are using a
delimiter which is uh the syntax is
followed as DB dot collection name dot
file and within the parenthesis pension
the field name that you are using right
you want to find a subset of data or the
uh you know a specific pattern that you
are searching for and then mention the
regex keyword and then the pattern now
if you look at uh the pattern inside the
pattern I have mentioned it delimiter
so
which basically means that you can like
find any pattern of a string value let's
say if I want to find a person's name uh
who has let's say RA in their name so I
can just simply put a delimiter and
inside that I can put a put the two uh
you know strings which is r a so for
example it can match Rahul and and any
such other names uh in the same way as
well so in that way you can use the reex
operator without using any uh without
using actually uh the regex pattern next
we have another uh Euro syntax of the
same regex operator which is mentioned
the field and mentioned the Rex operator
using the dollar sign and let's say if
you want to find a specific character so
we use circumflex or to the power which
is a meta character to match a string at
the beginning and we use a dollar sign
at the end to match a particular string
that ends with a particular value and
next we also have another you know type
of Syntax for uh X operator which is
field mention the field name and the
regrets keyword and mention the pattern
it can be anything it can be a generic
one where you can use delimiters or you
can even use the circumflex or the
dollar sign and apart from that we can
mention the options as well now we have
various different options like s uh I X
and F now what the S option does is it
allows the dot character to match all
the characters including the new line
characters that you are entering in a
document now we use x as an option to
ignore all white space characters in the
reverse pattern next we have I which is
used to match both upper as well as
lowercase patterns in the string and
finally we use m in order to
specifically search for the circumflex
and the dollar sign inside the string so
if these are not used these anchors
match at the strings Ender beginning now
this is a bit confusion for you guys so
let us understand you'll understand it
in a more better way when we get into
the execution part so I hope you
understood what is Rex operator so let's
just start understand how reget's
operator works with a simple example
here now let's say I have a collection
let's say its name is orders and within
the orders collection I have three
different documents here of three uh
different customers like Rahul pranav
and giti
now let's say if I want to find uh you
know the customer name who has RA in
their name now it can be at the starting
it can be middle or it can be elsewhere
or the in the end I mean so for that I'm
just using a delimiter uh and I'm
mentioning two uh string values that is
R and A so it will only match Rahul
because we have R A and similarly we
have pranav who is also having R and a
uh strings uh characters in in their
name we also have kirti but she doesn't
have R A so it doesn't match so we only
have we'll get the output of only these
two documents now similarly let's say if
I take another example wherein I am
writing another query which is DB dot
all orders dot find and I mentioned the
field name payment mode and I'm finally
for a particular string here which
starts with C A which is the payment
mode in the document should be it should
start with CA now we have payment board
as card cash and again we also have uh
card and cash are basically the two
types of cable mode so it will basically
retrieve all the three documents
so let us now understand another example
here now let's say I've written a query
which says DB dot orders file payment
mode
uh sorry uh I think there is a mistake
here uh so let's say if the orders item
uh I'm taking the field as order item
and I mentioned the rate at c word again
and here I'm mentioning dollar okay that
means the item name in the orders item
the item name should end with okay so we
have different item names here like
notebook paper General and postcard now
only one item name which is notebook
which has okay in the ending right so
the dollar signal basically matches the
string in the end so since it has okay
uh the two uh specific strings in the
end of the uh you know document so it
will only match the notebook so since we
have notebook in all the three documents
again we can retrieve the three uh
documents in our final output so this is
how regex operator basically works so
let us now directly jump into mongodb
shell for execution part and see how it
gets executed with some more different
examples
so as you can see uh the database mobile
DB shell has started so let us just use
the show DBS
in order to display the uh database that
are present so we have this simply
called one which will be using again so
I'm just using simple code one
and let us now see the collections
inside this we have the employer
collection so let us just use that so in
order to find the data that is present
we will use the DB dot correction images
employee DOT sign command
so it will display all the documents
that are present
so firstly let us discuss a simple
example where we'll uh simply use the
delimiter operator in order to find
you know the first name of the employees
in our documents whose name can have l i
okay so then we're just providing a
pattern here which is a line so the
query would be DB Dot
employee dot find
open the brackets square brackets and
within the flower packets mention the
field name that is first name
and then mention the delimiter which is
this and our pattern that we are trying
to find is L I write so mention l i
and again close the brackets
and enter
so all right so we can see some of the
documents have been retrieved let's say
if you take the first document here we
have the first name Valli and his full
name is patabala so you can see we have
characters Li at the end here so
similarly if you take the next document
we have Shelley Sim again we have Li at
the end and if you take this example we
have Julia whose name has Ali characters
in The between and next we also have
Williams who has Li in between again so
these are the five documents that are
received so irrespective of whether
irrespective of the position in which
they are it basically retrieves all the
documents that has Li as a substring in
the uh document so in this way you can
use uh the rejects operator also simply
without using the regex uh you know
keyword
so let us now understand another example
guys so let us say uh I'm trying to find
a specific pattern where I want to find
the first name of the employee whose
name starts with s h so in that case
what I'll do I'll write a simple query
as
dot DB dot employee dot find
open the brackets mention the field name
which is first name and again now we'll
write the regex keyword here
since we are particularly finding a
pattern which says that the name of the
employee the first name of the employee
should start with only S and H
so mentioned the dollar symbol mention
the regex keyword
and semicolon and then within the uh
double quotes mention the words or the
pattern that you're trying to searching
for so I'm keeping it as S and H so let
us close the windowed commas let us
close the flower brackets and
and finally the square brackets I think
we need to mention two flower brackets
so I think we are good to go so let's
just execute the statement all right so
as you can see the resultant set we have
some documents being retrieved so
firstly if you look at the uh document
of this one who's the employee whose
first name is Shelly so it's starting
with SH next we also have uh employee ID
123 whose first name is Shanta again
started with SH and similarly we have
embroidery 2.5 whose first name Shelley
starting with SH again so you can use
the Rex operator in this way to only
find a particular pattern
now let us take another scenario here so
if you look at this previous example now
we are mentioning uh the pattern as
capital S and H so it is case sensitive
right so it is already displaying the
records of those employees whose uh
first name is starting with capital S
and the second letter which is small H
so let's say in in a different scenario
we want uh all the employees name whose
name is having uh let's say capital S as
well as well as Capital H so in that
case you need to use the options uh you
know command so let's say again if I am
trying to find the first name of an
employee uh whose uh first name starts
with ju so it can be capital j or small
U so in that case you'll need to use the
options and the option that we are going
to take is which is basically I
so I'm just going to uh execute this
statement so just follow it with me DB
Dot
employee Dot find
and within the square brackets
open the square brackets and the flower
brackets first name
and open the flower brackets again
mention the dollar sign
mention the regex keyword
again semicolon now the pattern that I
am searching is ju it can be anything so
we are just going for case insensitive
here now for that we have to basically
use the options command here so mention
the dollar sign
options is the keyword
and mention the column
and within the Brack uh inverted quotes
mention I
so what basically this I does is it will
retrieve all the records irrespective of
whether they are in uppercase or
lowercase so
let us just close the follow brackets
again and let us execute it
so as you can see we have only uh one uh
record or one document that is being
retrieved which is of Julia Dyer now if
you look at the comment that we have
taken as small J and small U but in the
resultant output the uh the the document
is that which has been retrieved is
capital J and small U so in this way you
can use the options uh you know command
you have to find all the documents
irrespective of whether they are in a
smaller case or uppercase so that was
one another scenario guys so finally let
us look into another scenario where you
want to find
you know a specific document starting
with a particular uh substring or sub or
a pattern or a value and ending with a
pro a particular value
so firstly let us take uh
an example of uh you know this document
wherein will search for the job ID which
starts with a C so in that case the
following query would be DB dot employee
dot find
mention the flower brackets
so we are taking as job ID which is our
field name
mention the regex keyword again
so the pattern that we are searching for
is so circumflex you have to mention
this uh symbol which is a meta character
and the job ID should start with A and C
so it is must so this condition
basically checks for all the job IDs the
name of java IDs starting with AC
so let us just close this and
enter
all right so in the resultant output we
have two different documents present so
if you look at the first document we
have job ideas AC MGR and next to the
second job ID we have AC accountant
so this was another scenario where we
are using uh you know various finding
documents only uh with us with the help
of the regex operator and a search uh
pattern wherein we are only finding the
job ID of those employees whose uh job
ID name starts with AC so that is the
end of today's session guys I hope
you've understood uh all about mongodb a
regex operators and how to use them now
projection in TV is a special type
of feature guys that is used to select
only a certain part of the data without
selecting the entire data present inside
the document
so more on that soon but before we get
started uh let's discuss the agenda for
today's session
what are the tutorial by understanding
what is more DB projection and then we
will understand why we use projection
and more and after that we'll have a how
projection Works in mongodb turn its
syntax usage and next we'll discuss
projection queries with the help of
certain examples and finally we'll
execute those examples in mongodb server
I hope I made myself clear with the
agenda alert what is mongodb projection
now mongodb projection helps to return
the specific fields from the query or
you can see from The mongodb Collection
Now by these
collection in mongodb
documents
so as you know mongodb is a schema LS
database which is a nosql database and
has a different structure to that of
relational database now the tables in
relational database are called as
collection rows are called columns are
listed we may not want all the records
from the collection but a few of them in
the resultant set so in that case we use
mongodb projection using projection
document which is used to limit the
amount or fields in the data present in
that document so in a nutshell if I
would say projection means selecting
only then
necessary data
other than select
ing the whole of the data present in the
document now similarly as to that of
where conditional Clause that we use in
SQL because if I have a document which
has 10 fields and you need to push and
why we use a popular nosql and open
source document oriented database which
allows for highly scalable and flexible
document structure which is faster than
relational database because of its
efficient storage and indexing uh
techniques and being a nosql database it
is designed to handle large amounts of
data so DB will process a lot of
unnecessary data and you want when you
want to retrieve specific information
from a large number of Records so to
overcome this problem we use projection
query now some of the reasons Now when
using projection to remove unused or any
sales the military server will have to
fetch each document into its memory and
then filter the results to return uh
actually reduce the memory usage but can
save the significant network band for
query results depending on the data
model and the fields projected in your
documents and it only returns index
query results without fetching the full
documents now which is basically the
main use case of projection which
basically eliminates all the fields that
are unnecessary for the user and
particular Fields within the document
then he can use the production area
operator
and finally data without the overall
database is performance
by default is return all fields and
matching documents so if you need all
the details it's returning
full documents is going to be more
efficient having a server manipulate the
result projection however then to
recruit performance and that is one of
the main uh consideration when we are
using mongodb projection so these are
some of the reasons on why we use
mongodb projection all right let us now
understand how mongodb projection works
now in general to retrieve the data from
the uh documents we use the find method
uh which retrieves data from all the
fields within a document without any
filtering
so let us now understand the syntax of
mongodb projection operator now the
syntax is followed as DB dot collection
name DOT fine and within the parenthesis
mention the field names that is I'm
taking your field one and its
corresponding value field 2 and value 2.
now
the values that I'm talking about is if
field value is set as 1 which is a
Boolean expression uh which is equals to
us it will basically show the data in
that field field value is if the Boolean
expected hides the data in the field so
let us understand this with an example
guys I the only then you will get a
clear understanding of it now I have
let's say a collection of uh certain
documents let's say the collection name
is orders and I have three such
documents here which has various Fields
like ID customer address payment mode
email order total and Order items now if
I want to display all these documents uh
what I'll do I'll basically write a
query using the find method which is
followed as DB dot orders DOT fine so it
will basically retrieve all the
documents without restricting any of the
fields that are present in our
collection
now let's say if I want only particular
field that I want to display in my
resultant cell now let's say if I have
uh the payment mode and the order total
sealed and I want only them to display
in the resultant set without displaying
all the fields that are present in each
of the document so in that case I'll
write a query as DB dot orders dot find
and inside the parenthesis I'll mention
payment mode colon 1 and order total is
one now since I've set the field value
to 1 it will only retrieve those values
and similarly for order total also it
will retrieve only that particular field
value so this will basically be the
output of our resultant set that is it
will show the ID object the payment mode
of the three documents and similarly the
order total of the three documents Now
by default we have the underscore ID
which is a default value which we cannot
change it so if if at all if you want to
override and change it you can mention
it to 0 now let's say uh I'm taking the
same example here now instead of just
writing payment mode to one and order
total to one I'm adding another uh you
know constraint or I'm using I'm
projecting another field which is of ID
and I'm setting it to zero now if you've
seen a result and set we do not have the
ID field so in this way you can use
projection in order to restrict certain
fields from your resultant table set
without actually retrieving all the data
that is present in your documents so let
us now jump into shell and execute
this example and see how it is working
so as you can see uh shell has
been started now I don't want to get
into the details of all of it I will
cover in a separate tutorial where we'll
understand how to create a database and
how to create a collection in mongodb
separately guys straight into the
channel for that so we'll just cover uh
how we'll Implement mongodb uh
projection with certain examples here
now the basically uh in order to
retrieve the databases that are present
in our mongodb we have to use
recommendous show DBS so it will list
out all the databases that are present
we have admin config local and simply
code one now I have already created uh
the simply code one and hindsight before
itself so that they can save a bit of
time and have already created a
collection in that so before you see the
collection and the documents that are
present in it you have to use uh the
simply code database so for that we'll
use the simply code one as our Command
so as you can see it is saying that
switch to DB simply code now if you want
to find all collection that are present
in database you have to uh basically
write as
social collections so it will list out
all the collections in that now as you
can see I have a collection that is of
employee here so for example I will
consider this same collection now I have
this below collection named as employee
with uh let's say certain number of
documents in that now if I query the
collection in the shell if I write
a command to it to return all the
documents or fields from the matching
documents by default it will basically
it will return all your documents so for
that I will use a statement like
pictures of DB
dot mention the collection name that is
employee dot find so file method is used
to list out all the documents so you can
just see that we have a lot of documents
in our resultant Set uh let me just
scroll and go to the top so as you can
see we have different documents a number
of documents and it has different fields
like ID employee ID first name last name
email phone number hiring date job ID
salary manager ID Department ID and so
on so you can see we have a lot of
documents so let's just count how many
documents we have for that you can use
the count statement
so
DB dot employee dot count so you can see
we have a total of 50 documents present
in our employee collection now if you
look at our resultant set after we used
the fine method you can see it has
returned all the fields of the document
from The Collection now but what if I
want to fetch only a particular field
like let's say first name last name
email or even their salary
how will we do that now the answer is
using mongodb projection we will Project
Specific fields to return from the query
now so before proceeding to mongodb
projection guys let's recall how we fit
certain fields from you know our
traditional SQL database so that we can
have a clear understanding now let's say
suppose The Collection employee is a
table in SQL and let's say all the
fields like employee ID first name last
name so on are its columns now I want to
fetch the only uh the let's say first
name last name
uh from the table so in that case what
we'll write will basically write us
query as select first name
last name from a table that is employee
right I hope I am clear with this so it
is similar to that in mongodb wherein we
are executing this query as uh using
projection so let us now see how we do
projection here so let's just uh
consider as an example here now let's
say I'm writing a command as DB dot
employee dot find
and let's say if I want to fix all the
documents of all the employees whose
Department ID is 30. so in that case
what I'll do is Department
so it is says a case sensitive guy so
make sure you write in the capitals or
whatever the field is written as
so mention the column and within the
double quotes mention 30.
so close the uh parenthesis and close
the square brackets as well so it will
basically list out as you can see all
the documents of the employees whose
Department ID is 30. so we can see we
have employee ID of the employee 114 115
116 117 118 and 119 whose all their
department is 30.
now again even if I'm returning a
particular field or a condition it is
also you know retrieving all the fields
from all the documents now I don't want
that now I want only a particular field
so what in that case we will project
certain Fields without returning all the
fields from our documents so let us see
how it works so the query is followed as
DB Dot
mention the collection name employee
find
open the square brackets
and let's say uh I want to retrieve only
the first name
first name so I'm setting it as one as
we discussed earlier if you want to
retrieve the particular field you have
to mention one and similarly I want to
mention I want to retrieve the last name
as well
last name
column and one and also let us take
another field let's say a salary
right we have salary also let us just
retrieve that as well as one
all right close the parenthesis and
close the square brackets and enter so
we do not have any output here guys that
is because we haven't mentioned the
parenthesis uh before the find method so
let me just copy based and we'll see how
it is
so before after the find we'll have to
mention the uh parenthesis again
okay
and then I think we are good to go now
so as you can see in a resultant set now
since we have only mentioned the first
name last name and the salary it is only
displaying the results
only those only certain fields that is
the first name last name and salary in a
result and set now by default this ID
object is uh you know retrieved uh with
the command so if you want to eliminate
that as well you can keep the ID to zero
so let us just execute that so let me
just copy this again
paste it and mention another uh criteria
that is
the field now the field should be
the field that is of ID should be zero
so close the parenthesis
so let us just execute this and we'll
see how it is the output so as you can
see now only we have the first name last
name and salary of all the employees so
we have just basically eliminated the
object idea as well so if you want uh
only uh the first name last name and
salary in your output you can just
mention the field names and mention one
if you want to display a resultant set
and if you want to display if you do not
want to display those certain Fields you
can mention as zero so in this way you
can use the projection query operator in
order to project only certain fields
from all the documents so yes I guess
that was all about the mongodb
projection guys uh now projection query
operator can be quite useful when you
are handling a lot of unstructured data
let's say if the database has like 10
000 or even a million records in such
case if you want to return a specific
number of fields only now a document can
have any number of fields like 10 20 30
40 and so on so in some cases if you
want to retrieve or specify only certain
number of fields in a resultant set in
that case projection operator can be
quite useful and I know it is quite
confusing at the beginning so just you
just need more practice to understand
this in a more better way
so
that brings us to the end of today's
session guys I hope you have understood
all the topics and Concepts covered in
so sorting and limiting uh one of the
necessary database operations it helps
to simplify and the readability of the
data and sort the data as per the user
requirement now when you're working on
huge chunks of data in a database both
sorting and limit operations can be
quite a handful to understand and
visualize data in order to get
meaningful information out of it and
retrieve only the specified number of
Records accordingly as per your need so
in this tutorial you will learn all
about the sorting and limiting Concepts
and how it can be implemented in mongodb
database
so before getting into the execution
part let us quickly understand what is
sorting in mongodb sorting is the
ordering of data in an increasing and
increasing order based on set of
relationships between the various data
items present in the database now
sorting can be done on any entities
having information like ID name is
address or any data type having numbers
or string values now sorting improves
the readability and consistency of the
data displayed from the database so in a
nutshell sorting is done just like in
any other database or programming
language that involves arranging data
into some meaningful information to make
it easier to understand analyze or
visualize let us understand its syntax
the syntax is simple it is followed as
DB dot collection name fine dot sort and
within the parenthesis mention the field
and the order so let us understand how
it is now for sorting your mongodb
documents you need to make use so this
sort method so this method will accept a
document that has a list of fields and
the order for sorting so for indicating
the Sorting order you have to set the
value 1 or -1 with this specific entity
based on which the ordering will be set
and displayed so if the order is is one
it will basically
uh sort the records in ascending order
that is in an increasing manner and if
you mention the order is -1 it will
basically sort sort the uh data in a
descending order that is in a decreasing
manner so one indicates organizing data
in ascending order while -1 indicates
organizing in descending order so that
was all about the Sorting in mongodb so
let us now understand how sort method
Works in mongodb with an example now
consider a collection name orders now if
I just run a command DB dot orders dot
file I'll get these a collection which
has three documents so it has uh details
of three customers like Rahul pranav and
kirti right so let us now run a query
where I'm using a sort method here which
is followed as DB dot orders dot file
and within the parenthesis I am
basically uh projecting the query ID so
that we will not have it in a resultant
set so and also I'm sorting the data
based on the customer here so I'm
mentioning customer
as well so that means it will basically
order in
the ascending order so this will be the
output guys now the output is now first
you'll have the customer uh details of
kirti because the letter alphabet K
starts first in the alphabets uh from A
to Z next we have Prana which starts
with p and then we have Rahul which
starts with r so this is a simple
example on how sorting method Works in
mongodb now let's say if I want to sort
multiple fields in a collection so in
what way will I be able to do it now let
us consider an example here let's say I
have a pet info collection here and we
have various records or you can say
documents and we have uh like various
Fields like name of the pet type and its
weight now let's say if I want to sort
multiple Fields uh within this
collection so I would write a query as
DB dot The Collection name which is pet
info DOT fine dot sort and next I am
sorting this collection based on its
type its weight and finally the ID
so type I'm giving it as one which will
basically do in an ascending order which
is an increasing manner whereas I am
doing uh the Sorting on the weight field
as minus 1 which is in decreasing order
that is in descending order that is from
highest to lowest and then I'm also
sorting the field ID as uh ascending
order that is I'm giving it as one
so when I run this command in mongodb
Shell this will uh this will what we are
basically basically the output of the
collection right so let us just
understand how it is working
now first I am uh sorting the data based
on that type now the Sorting is done
based on the priority that is given that
is first you have given the uh sorting
input as type then weight and the ID so
it will run the Sorting based on this
sequence only
so if you look at the first uh record of
the document we have uh the cad data
that is the we have three uh records of
cads uh having the same uh type right so
we have Lily Millie and Oliver which is
of type cat so basically it will arrange
those in ascending order since we have C
which is the starting or the uh
alphabetical or order of the alphabets
uh which comes uh the C comes first then
we have dog next we have kangaroo now
since we have uh the same records or the
same uh record of cat that is repeating
then it will check weight now since we
have given weight as minus 1 that is
from descending order that is why we
have the record of Lily whose weight is
12 at the first place next the uh
details of Milli whose weight is eight
and finally we have Oliver whose weight
is seven
so this means that if there are multiple
pets of the same type those pets are
sorted by their weight in must
descending order now if there are
multiple pets with both the same type as
well as weight then those pets are
sorted by the ID field which you have
given to sort them in ascending order
now if we hadn't included the ID field
in the Sorting process then those pets
of the same type and the uh sorting
process then those threads of the same
type and weight could appear in any
order guys so without having a sort
field on a unique field such as the ID
field it would be entirely possible that
the result would come back in different
order when we run the query each time so
I hope you understood how the Sorting
works when we want to sort multiple
Fields within a document
so let us now understand what is limit
in mongodb the limit method in mongodb
is used to limit the number of Records
this method takes only one number type
of argument which is basically the
number of documents that you want to
display in your resultant set similarly
which we used to do in SQL also wherein
if we have like thousands of Records you
use the limit clause in order to
restrict a certain number of records and
specify only certain records in a
resultant set now the syntax is followed
as DB dot collection name dot file limit
and value now in the value you can give
as per your choice let's say if I give
the value as 5 it will display the first
five records or the documents from that
collection and similarly you can also
uh use the projection where you can
display the fields as per your
requirement by giving the values and
also the limit value and simultaneously
you can also sort the data and the limit
uh and limit those uh collections or
Limitless documents in the collections
as well and the syntax is followed as
db.collection name DOT fine dot sort
field order you can give multiple field
names in the Sorting uh you know
parenthesis and mention the limit method
and you can give the values that is
number of uh Records that you want to
fetch in a resultant table so let us now
understand again how limit Works in
mongodb now again let us consider uh the
orders collection here now let's say if
I want to limit these collections now if
I want to retrieve only the first two
documents from this then the query would
be DB dot orders dot find limit and
within the parenthesis I'm mentioning as
two so this would is this would be the
output wherein you will get the details
of Rahul and Prana which are basically
the first two documents which are
present in our collection order all
right now what if you want to sort and
as well as limit the data now what I'm
doing here is I'm basically projecting
the ID field so I'm keeping it as 0 so
that we do not have this in a resultant
set next time sorting uh this collection
orders based on the customers so I am
giving customer as one which will
basically uh
sort the documents of the customers in
an ascending manner that is from lowest
to highest and then I'm limiting these
documents for only two values so uh when
I run this query this would be the
output
so customer I'm basically sorting in
ascending order so first we'll have qtp
and similarly next we have product in an
alphabetical order which is following
the alphabetical condition starting from
A to Z and since I am also using the
limit Clause here up to two values it
will only retrieve the first two values
so this is how limit Works in mongodb
guys I hope you've got a better
understanding on how limit works you
know consider in this simple examples so
let us now jump into mongodb shell with
a proper execution and see how it gets
executed
so as you can see mongodb shell has
started and let us consider the
simplifier database again so let us
write the command as you simply code one
which will basically select the simple
code one database and
let us see what are the collections
present in it and we have the employee
collection so let us just retrieve the
data that is present in this so I'm
using the find method PP Dot and send
the collection name and mention if find
method so it will retrieve all the data
that is present in it so we have uh data
like employee ID first name last name
email phone number hiring date job ID
salary manager ID Department ID
so firstly let us discuss some example
choosing the Sorting technique guys uh I
think we already have employee IDs in
alphabet I mean in sorted order so let's
just take another field let us sort the
manager ID field here so the following
query would be DB dot employee
dot find
mention this sort
and within the sort mention the field
name which is manager ID
so I'm giving the order as one which
will uh sort the order in ascending
order
so close the parenthesis and let us
execute this
so basically you can type it to retrieve
all the records that are present so let
us just understand how it is working let
me just scroll back
you have so many records guys so it's
better we use the project field uh so
that we can have a clear understanding
so next time we'll use that
so this is our query which you have
executed now now since I've sorted the
manager ID in ascending order which I
have given the order value as one as you
can see uh since we do not have any
manager ID for this employee Stephen
King next we have the manager IDs 100
and next similarly we have hundred
hundred hundred
100 and so on and next we have one not
one
and one not a so as you can clearly see
114 as well uh so you can clearly see
that our data has been sorted in
ascending order when we are using the
Sorting technique so let us now
understand how we can do that with
another
you know sequence that is let us keep it
as minus one so in that case what it
will be is DV dot employee find
so I'm going to project some of the
fields because uh I don't want all these
uh you know unnecessary fields in my
resultant set so I'll just uh opt them
out so I don't want ID field
so I'm keeping it as 0
and I want first name
my resultant set so I'm keeping first
name next I want last name as well
keeping it as one and next last name
uh
and let's say uh finally manager ID only
okay
manager
ID
has one close the parenthesis now
mention the sort keyword
open the parenthesis mention the
field that you want to sort
in the way that does manage your ID
[Music]
so it is important that you mention
manager ID in the projection field right
so if you do not mention and if you are
sorting manager ID without explicitly
calling it so you will get an error it
won't display so it is important that
you mention the manager ID in the
projection field also
close the brackets I think we are good
to go let us just recheck our code
oh okay okay right so I think there is
an error in the manager ID guys so let
me just copy this you know
so you might have a technical error so
make sure you give the correct name of
the field name otherwise you'll get an
error so I think we are good to go now
so let us just like figure this
statement and we'll see the output so as
you can clearly see that in a result and
Set uh we are only fetching the first
name last name and manager ID since we
have projected some of the fields uh in
a resultant set and I'm sorting the data
based on the uh based on the manager ID
field and since I've given it as one it
will uh sort the data in ascending order
that is from lowex to highest so if you
can see the first
manager ID is 100 so list of all the
employees whose manager ID is 100 has
been shown next we have one not one one
or three uh single if you type it we'll
have the rest of the records as well so
you can see next 108 114 120 and so on
120 to 123 to not one two not five so in
this way you can sort my uh various
documents in order of how you want to
display or show them in your resultant
set
all right I hope you understood this
till now uh let us now sort multiple
field guys so let me just copy this
query
now again like as we discussed earlier
in in our presentation sorting multiple
Fields is not a big task it is just
simply that you have to add the uh
multiple Fields here so manager ID as
well as let's take salary also
so what I'm going to do is I'm going to
sort salary in uh descending order so I
am mentioning it as minus 1 and also let
us uh project the field here as well
so salary
has one all right so let us execute this
statement and we'll see the output
so as you can see in a resultant set
after sorting the data based on the
fields of manager ID and salary if you
look at the output now since we have
sorted our manager ID in ascending order
since we have specified one as the order
it will uh basically sort the order in
ascending order that is from lowest to
highest and salary we have mentioned the
order as minus one so it will do the
opposite of that that is it will sort
the data in descending order that is
from highest to lowest so if you look at
the resultant output here guys
now since we have no manager ID for this
which is uh taken as let's say the least
value or zero so it is displaying first
next we have the salary minus one so if
you look at to the manager IDs uh of the
next uh like let's say four now since we
have the manager ID hundred which is the
lowest value and we have four same or
four or more same values then it will
move on to the next priority that we
have given to sort our document that is
salary so first now we have 82 000 as
our salary that is from descending order
it will uh basically sort the data in uh
descending order that is from highest to
lowest so we have 80 to thousand next we
have 80 000 next we have seventy nine
thousand eight hundred next we have 6558
000 next we have Seventeen hundred
Seventeen hundred similarly and so on
so in this way you can sort multiple
Fields using the sort method as well I
hope you've understood how the sort
method Works in mongodb guys uh using
the single field or using multiple field
sorting how you can basically arrange
the data based on your name
all right let us now uh discuss some
examples using the limit Clause again
limit Clause is very easy guys it is
used to restrict or specify only certain
number of Records in a resultant set and
the uh
syntaxes followed as DB dot mention the
employee name DB dot Empire dot find
dot let's say limit I want only five
records of the uh you know employee
collection so I'm mentioning as Phi as
my value and when you enter uh when you
press the enter you can see the
resultant output has only five five
documents one two three
four and five so this is a simple
example of how you can use limit now you
can also use the limit using the sort
method as well so let us just copy this
and we will see how it gets executed
so let me just paste it here
now I'm just adding the limit method
here I want only let's say the first
four
okay now what I'm doing is I'm first
basically projecting some of the fields
that is the required number of years
that I want to fetch in my resultant set
then I am basically sorting this
documents in the uh manner of manager ID
salary in order of ascending order from
manager ID since we are given one and in
the order of descending order for salary
since we have given at -1 and I am
limiting the resultant uh you know
output to only four records so when I
press enter you can see we have only the
first four records so we have no manager
ID again next week if we consider the
manager ID here 100 for Adam Frip whose
manager ID is 100 and next two also we
have this same manager ID here guys so
now the next uh thing is it will go on
to this salary like we discussed earlier
the salary is uh sorted here in
descending order from highest to lowest
so we have 82 000 next we have 80 000
next we have seventy nine thousand so
similarly if you can
uh let's say let's limit to another
example let's say if I'm limiting to 10
all right so in that case it will
basically fetch the first n record so as
you can see one two three four five six
seven eight nine ten so all of them are
basically uh the records of the
employees whose manager ID is 100 and it
is basically arranging all the details
of the employees salary in ascending in
descending order that is in the order of
minus one which we have specified
so that brings us to the end of today's
session guys I hope you all have
understood all about the sort and the uh
limit method that we use in a good
indexing strategy is essential for
ensuring that your you know database
returns your results as quickly as
possible now just like any other
relational databases where we perform
indexing similarly indexing in mongodb
is also a way to organize information so
that the database engine can quickly
find the relevant results more on that
soon but before we get started let us
first discuss the agenda for today's
session
in today's tutorial we'll be going
through different concepts wherein we'll
cover what are indexes in mongodb and
then we'll understand why is indexing
used in mongodb and up next we'll
discuss how does indexing work and then
we'll understand how to create an index
and after that we'll be going through
different types of indexes used in
mongodb and finally we'll end this
session uh with syntax and execution in
mongodb Shell I hope I made myself clear
with the agenda part so let us just go
ahead and understand what are indexes in
mongodb
so what are indexes in mongodb now
mongodb index is a special data
structure on which the data is on which
the index is created to hold the date of
specific fields of document now in the
absence of uh you know fields in the
fields and indexing in mongodb there is
a need to scan every collection document
to select those uh that match the query
statement now this scan requires mongodb
to process a large volume of data and is
highly efficient so if there is no
indexing done on a collection of let's
say thousands of documents your query
will keep finding specific documents in
order however mongodb would limit and
make it clear the number of documents to
be searched within your collection if
your documents have indexes so with the
help of indexes when they are applied at
the collection level it can store the
value of a specific field or set of
fields ordered by the value of the field
so those were that is what indexes are
in mongodb
let us now understand why is indexing
used in mongodb now mongodbs indexes
make it unnecessary to perform a
collection scan now from that what I
mean is collections can basically
involve looking through every document
in a collection that matches to your
query that you have written to find a
particular or document or a field that
you are trying to return so when you
provide an indexing on documents let's
say on a database that you have like a
thousands or 50 000 records you can just
simply put an index which will improve
the search efficiency as well now any
collection in mongodb can have one or
more indexes and those indexes can be
made on one or multiple Fields And even
though a mongodb database can hold a lot
of data you need a good indexing
strategy to quickly and effectively
access the data you require from it and
finally indexing is a necessary
operation in mongodb which automatically
brings search efficiency in various
executions of statements all right
moving ahead let us now understand how
to create an index now creating an index
in mongodb is done by using the create
index method
foreign
go through these syntax uh so the syntax
is followed as db.collection name dot
create index is the keyword and make
sure the i in index is capital otherwise
it will throw an error within the
parenthesis mention the field name that
you want to create and index on and next
we have one or minus one so one of these
following syntax shows how to add an
index to our collection so let us assume
we have you know same uh like employee
collection which is an example which has
various Fields name like employee ID
name salary or so on but for this I'm
creating an index on employee name and
I'm specifying as one now the one
parameter indicates that when the index
is created with the employee name field
value they should be sorted in ascending
order now please you have to note that
it is different from the you know
hashtag ID which is the by default ID
which is uh you know created when you
are creating a document so the ID field
is used to uniquely identify each
document in the collection which is
created automatically in the collection
by mongodb and the document will now be
sorted as per the employee name and not
the ID feed
so I hope you've understood how to
create an example you will get a clear
cut idea when we go into the execution
part in mongodb so make sure to watch
the video till the end guys
all right moving ahead let us now
discuss the types of indexes used in
mongodb now there are mainly three types
of indexes in mongodb the first one is
single field index next we have the
compounds compound index and finally we
have the multi-key index let us discuss
about each of them in detail now now we
know that a field in a document in a
collection can be indexed individually
so as the name suggests single field
index is used to create an index or only
a single field in a document So Below is
an example and the syntax for single
fill index uh on an uh tape on a
collection named as orders so the syntax
is DB dot collection name dot create
index and within the parenthesis field
name so you can either index them in the
order of ascending or descending by
mentioning one or minus one so I have
considered an example here of orders or
collection where I've created a index on
a field called price and I'm mentioning
as -1 so it will basically index in
descending order that is from highest to
lowest
next we have the compound index now
compound index is formed when multiple
fields are combined into a one single
index so a compound index is General an
index that holds a reference to multiple
Fields within a collection so for
example I have taken another uh
collection I mean the same collection of
orders and I'm creating an index where I
am creating index of multiple Field
Services which is for price and for
customer name so again the syntax is
same which is DB dot mentioned the
collection name dot create index which
is the keyword and within the
parenthesis you can give as much as many
as you know field names to your name to
your sorry to your collection so I hope
you have understood what is copper index
as well so and finally we have what is a
multi-key index now mongodb supports a
multi-key index for each element inside
the array for an array field so these
elements consist of you know scalar
Fields like string values integer values
or even nested objects now the uh syntax
is same you just have to mention uh the
collection uh name and mention the
create index keyword and within the
parenthesis mention the field name which
is of only array type so multi-key index
you know automatically creates a multi
key index on an array by knowing its
structure so therefore you need not
additionally Define a multi-key index in
such case so no additional definition is
required as such so let us understand
with an example here now let's say I
have a document here
uh different documents like I have three
different documents in a collection of
orders which has various Fields such as
ID customer address payment mode email
order total and Order items now if you
look at this collection I have order
items which has an array values for
example we have for first ID for
customer Rahul we have four different
array values of order items like item
name notebook and item name paper item
name Journal item name postcard so if I
want to create a multi-key index I'll
just simply write a query as DB dot
orders dot create index and within the
parenthesis mention the collection uh
mention the field name that is which is
order items and on which you want to
perform multi-key indexing now I want to
perform uh indexing on price which is a
array value within a collection right so
that is what I'm taking is order items
dot price and the order in which it will
index is ascending so for that I am
giving the parameter as one so with that
we have covered all the three different
main types of uh indexing indexes that
we generally use in mongodb so let us
now switch into mongodb for execution
part and see how they actually perform
now we do not clearly see that how the
indexing is going but it will definitely
improve the search efficiency if you are
working on you know more than you know
let's say thousands and thousands of
Records
so let us now jump into uh
mongodb shell for execution part
all right so as you can see mongodb
shell has started and firstly let us see
uh what are the databases that are
present so for that I'll use the store
DBS and we'll again use the simply code
one or DBS that we have all previously
used so use simply code
one
it says switch to Simply code now if you
want to find all the collections that
are present in that you just have to
write show collections so we have one
collection which is employee so we'll
use that so in order to find the values
or the documents that are present in
this collection we'll just write the DP
command which is DB dot employee dot
find
so it will just display all the values
type it for all the values so as you can
see we have various different documents
in this so when this perform a simple
index now we'll just create a single
field index now which is basically a
normal field index that you create so
the query would be DB Dot
employee
create
mention the create index keyword and
within the parenthesis uh so let us just
create uh you know our index on salary
field here right so initially salary
field
mention the hyphen and we will uh Index
this in ascending order so I am giving
the parameter here as one so let us
execute this statement so when you
execute the statement it says salary
underscore one which is basically means
your index that you have created which
is has been successfully executed
so now that you've created your index
and if you want to view uh what are the
indexes that you have created you need
to use the get indexes keyword so let's
just find again so I'll use this
statement DB dot employee which is a
collection name now you need to use the
get indexes make sure the is are capital
otherwise you will find an error get
indexes and when you enter uh and when
you enter this and you will find this a
list of following uh indexes that you
have created now I have already create
now as I said earlier in the tutorial
the ID field is automatically created uh
within the you know database which uh
you know automatically creates the index
for the uh underscore ID but additional
to that I've already created email uh
index on our you know employee table and
just now I have created the salary index
also so you can see the list of all
these uh you know indexes that you have
created now let's say if you want to
or not delete or drop any of the index
that you have created so in that case
you have to use the drop index so I'll
just uh you know write the statement
again which is DB dot employee dot uh
mention the keyword drop index
okay and within the parenthesis mention
the index that you want to drop so let's
say if I want to drop the email I find
it unnecessary now so I'll just write
the email uh you know key key which is a
field and I have mentioned this uh one
and I'll just close the command this is
and I'll close the brackets as well so
as you can see it says okay uh you know
this it says an indexes uh is three and
okay one that means if finally you know
drop the index so we'll just use again
this you know get index and see whether
it is successfully deleted or not
let's just copy paste here and let us
enter so now you can see that we have
only two fields which is the underscore
ID which is you know by default which is
the index that I've created by the
database itself and additionally we have
the salary index that we have created
earlier and successfully we have deleted
the email
index from our collection or the
database so I hope you've understood
till now so that is what uh you know
index is about you know you just create
index to improve the search efficiency
now behind the uh database the
performance optimization or the
efficiency can be achieved which cannot
be viewed outside so I hope you
understood how to create a single field
here well let us now move to compound
index and we'll see how to create it
also
so I uh as discussed earlier you can use
multiple fields in a mongodb document to
create a compound index so I'll just
create a compound index on another
Fields so I'll just
create index
and within the parenthesis okay let us
now create uh you know index for let's
say job ID
job ID I am giving it as minus 1 the
order mention the comma
and let us create an index for let's say
Department ID as well
Department ID and I'm giving this a
parameter one it will basically index in
the ascending order so close the
parenthesis
so as you can see it is saying job ID 1
Department id1 that is me that means you
have successfully created the index so
let's just uh confirm whether they have
created or not
so let us copy paste again
so now as you can see we have another
two indexes that we have created which
says you know job ID and for Department
ID as well
so this is how you can create a compound
index in your mongodb database as well
so in the compound uh in the above
component is that well we have created
the mongodb will first sort by the job
ID in the descending order since we have
provided minus 1 as the parameter it
will basically sort all the documents in
the descending order then with each
department ID it will sort in ascending
order since you have provided the
parameter as one now the index would
create a similar data structure for the
Department ID also which basically sorts
the data in the ascending order so that
brings us to the final which is
multi-key index now I don't think we
have you know array of fields or the
array of data in our document documents
so that we can perform uh but for now I
think I hope you understood how to
implement multi-key multi key index as
well it just suppose supports indexing
of array of data so when you create an
index for a field containing an array
mongodb will create a separate index
entries for every element in the array
data
so I think we've already almost covered
all the topics that we have discussed in
our agenda and I hope you guys have
understood as well so that brings us to
the end of today's session guys I hope
you've understood what are indexes and
how they are used you know to uh search
the data in a efficient and a more quick
way so defining indexes are important
you know for faster and efficient
searching of documents in a collection
and these indexes can be created by the
uh using Create index method so I'm just
recapping what we have covered and
indexes can be created on just one field
by using the single field index method
or multiple Fields using the compound
index and you can even create indexes on
array of fields using the multi-key
index as well what is Advanced indexing
now we all know what indexing is mongodb
Right which is an essential component
which improves the performance of the
data retrieval speed in the database so
mongodb indexing is a special data
structure on which the index is created
to hold the data of specific fields of
documents and in the absence of indexing
in mongodb there is a need to scan every
collection document to select those that
match the query statement now in our
previous tutorial on indexing and
mongodb we have just covered the basic
uh you know indexing techniques like our
single field and comp and compound
Fields right so now what if the database
is working on array of fields within a
collection right uh so let's say if I
have a student's database and in that I
am working on sub documents that is
documents that have array of fields in
them so in such case the indexing
becomes quite difficult
so if there is no indexing done on a
collection of thousands of document your
query will keep finding specific
document in order be it a single field
uh multiple fields or even array of
fields so it becomes quite difficult you
know to retrieve the value so indexes
are applied at the collection level and
it can store the value of specific field
or a set of fields so before jumping
into why uh I mean how exactly Advanced
indexing works on you know array of
fails let us understand uh you know why
why we need Advanced indexing you know
in addition to the normal indexing that
we do in mongodb so for that let us jump
into my mongodb compass for explanation
foreign
so as you can see mongodb Compass has
started and in our database simply code
one we have two different collection
that is employee and new employees here
now if you if I click at the new
employees it basically opens uh the
document Fields now you can see we have
like almost around 33 000 documents and
we have one index which is basically
done on the ID field if you look at go
to the indexes page we have the ID field
which is already indexed now if you
consider these many documents right
these huge tons of amounts of documents
like we have 33k and if I try to find
a particular document let's say I want
to file uh a name you know based on the
name I'm trying to field
uh I think we have different names here
right so let's just take Department here
right so we have Department field
so I'm just filing value like let's say
uh I'm trying to find all the documents
which has polis as the department name
so I'll just write polish and try to
search it so close the brackets and let
us try to find
so it will basically find all the
documents or within the collection that
has Department as police here now if I
go to the explanation of this right
let's just click on explanation now if I
uh look the query performance of this uh
document or the query that I've written
for uh you know to find the details of
all the uh you know employees or the
people working in a company and the
background I'm trying to find what all
uh the documents that I want here right
so if you look at here we have a total
of thirty two thousand nine Twenty Eight
documents and in that we have documents
returned are thirteen thousand five
ninety
now it indirectly impacts the
performance guys now if you see we have
33 000 documents it is searching each
and every document where the department
uh is police so and after searching each
and every record a record it is
basically retrieving all the documents
so we have around 13590 which is close
to around 14k and if you look at the
actual query time it is around 23
milliseconds so that is quite a huge uh
you know amount of time for a database
to process such information now let's
say if I have like Millions like 10
lakhs or 15 lakhs of documents in such
case the time taken is more so in such
case we'll basically create an index
here now we all know how to create a
single index on a multiple index so
let's just create an index and we'll see
how it actually affects the uh you know
bigquery performance so I'm just
creating an index on Department field
and I'm basically indexing in ascending
so I'm just basically one I'm keeping it
as one so as you can see uh we have
created successfully uh the index for
the Department uh field here so let us
now try to uh find uh the data that is
the Department of that is the employees
or the people working as a police
so and if I try to sign this and if I go
to the EXP again explanation part
so you can see now we have a total of
Thirteen thousand five ninety documents
now instead of searching all the
documents that is 33 000 we can directly
reference a refer only those documents
that are required to us so you can see
index key examined only 13 590 and you
can see actual query execution time has
reduced a bit more like 17 Ms I think
that is also a quite huge but I don't
think uh that is you know uh that can
affect actually so you can see this is
how index works now let's say if I
create multiple index let's say if I'm
trying to find multiple uh you know
Fields so in that case let us see how it
actually impacts
all right so let us now understand how
it works for a compound field so when
you are trying to uh index uh multiple
Fields let us see how the query
performance does so let us know uh file
uh you know the details of the employees
whose department is police and let's say
the job titles is Sergeant so in that
case I'll basically search for
Department field where the department is
Polish
and put a comma and I've dropped it and
that I'm searching for is basically
Sergeant so mention SAR Gent
okay close the brackets and let us now
find the documents
so if you look at it will only display
all the uh details of employees who is
basically job title is Sergeant and
department is police so let us now
understand how it is executing so let us
explain uh click on the explain button
so you could you can see that uh the
documents it is examining is basically
the all the documents that is present in
the collection that is 32928 now out of
that it is returning 12 to 196. so as
you can see it is a time taking process
it is going through each and every
document now thing is we only have only
around 1300 documents where the
department is polished and the job title
is Sergeant so instead of that what I'll
do is I'll basically index the uh both
Department as well as the job title as
well so let us just create another index
here for firstly for Department
create index so let us create another
index for job title
and let us create an index again so as
you can see we have created the index
successfully so let us now try to find
the documents all right it will find it
it will fetch all the documents and let
us now uh
basically uh click on the explain and
see how it does so as you can see now
the documents that is that it examined
now is 296 which you've seen earlier
that all the details of employees whose
department is Polish and the job title
is Sergeant so after creating an index
it is only searching only those
documents whose department is police and
Sergeant as you can see the actual query
execution time is also reduced
drastically from almost 4 30 to
milliseconds to almost 16 milliseconds
so it'll also vary like if you click
again it will change to six milliseconds
now that it is find the details so it
keeps on changing so index basically
provides the user to efficiently
navigate through that data which is
required by them instead of searching
the whole data so now you might be
wondering why we need Advanced uh
technique now let's say if I have a sub
array fields in this documents so in
that case I need to query
those documents quickly right now it
will take more time than single field or
a compound field now that is where we
use Advanced indexing to uh index sub uh
array fields or sub documents so let us
now understand how advanced indexing
works and why we have uh you know went
through all that scenario on mongodb
Compass where we have understood how
indexing works for a single field as
well as compounding field and the need
for advanced indexing now let's say I
have a document of students uh let's say
I have the student ID their name age
courses now for courses field I have an
other additional uh you know array array
section where I am mentioning the course
ID course name and course credits so in
that case we have an array field here
right so in such case we'll use Advanced
indexing now Advanced indexing is
basically just another process where we
are using another technique right so
let's say if I have 20 million such
records right 26 million are documents
present in my collection it will take a
lot of time so this is where we need to
use indexing process again so let's say
if you are indexing an array field the
Syntax for that would be
db.collection.create index mention the
array field name that is and the order
so I am creating an index on courses
right uh which is an array field there
so the query would be db.students.create
index courses and mention the order that
is one now you can also further uh you
know index subdocument Fields right now
instead of just uh indexing the array
field you can also index the subdocument
field so let's just understand the
syntax here that is
dp.collection.create index field name
dot subdocument field name and the order
now why we are doing this now suppose
that we want to search documents you
know based on the course ID course name
or even the core uh course credits now
since all these fields are part of the
courses subdocument field right which we
will create an index here on all the
fields of this sub document now in this
example I have created an index field on
a subdocument which is course ID
similarly you can also create for course
name as well as the course credit also
so the query is followed as DB dot
students create index courses dot course
ID and I'm mentioning the order as one
so once the index is created we can
search for any of the sub document
Fields utilizing this uh in a query
now remember that the query expression
has to follow the order of the index
specified that is either 1 or minus 1
otherwise you will get an error so in
this way we can use uh a technique which
is Advanced indexing in order to query
the array Fields as well as sub document
Fields now in addition to that we have
some other Advanced indexing techniques
which is uh another three types of
indexing techniques in mongodb which is
first one is geospatial index now
mongodb uses 2D index and 2D spear to
increase the efficiency of database
queries while dealing with a geospatial
coordinate data next we also have text
index which provides support to take
search queries on string content so
basically text indexes can include any
field whose value is a string or an
array of string elements and finally we
have hashed index now basically hashed
index keep tracks of the entries with
hatches of the values of the index field
which is almost always the underscore ID
field which is created by default in all
the collection now this kind of index is
primarily necessary when you are
sharding data to distribute it evenly
now if you want to learn more about
sharding we have a dedicated video on
that as well so make sure to check that
on our Channel
foreign
guys so in this way you can use uh
Advanced indexing uh to create an index
on you know multi-key compound uh you
know Fields as well so let's say if you
have a document with an array field you
can just create indexing for an array
field creating an index or an array in
turn create separate index entries for
each of its Fields so it will basically
separate uh create an index to an array
field so it will help you to find the
documents with which are having any
array field values as well so I hope you
understood uh all the techniques and how
we Implement Advanced indexing in
mongodb mongodb you will most likely use
the fine method or command for a variety
of queries now however as your queries
become more complex you will need to
learn more about aggregation in mongodb
which is used to perform various complex
operations so in this tutorial we'll be
covering the fundamentals of creating
aggregate queries in mongodb and how to
use various expressions in mongodb
aggregation and furthermore we'll
introduce the most important stages of
aggregation pipeline along with examples
of how to apply each one to this
pipeline stages all right firstly let us
understand what is aggregation and
mongodb mongodb process the data records
in the database during an aggregation
operation and returns a single computed
result it actually groups multiple
documents present in a collection
applies an aggregation operation to it
and then provides a user with a single
result now mongodb offers a wide range
of aggregation operations just like many
other database systems in relational
databases as well mongodb being a no SQL
database also provides with the same
functionality this enables you to filter
data as you might with a query as well
as grouping data sorting data into a
particular order or reorganizing for
returning the documents in the
collection now this is just similar to
the SQL wherein we use the group by
clause in our aggregation function with
the help of certain operations like
count average sum minimum and value to
perform complex aggregation operations
in the similar way mongodb aggregation
is also similar to that of the SQL
aggregation method that we follow
so I hope you understood what is
aggregation in mongodb Let Us Now
understand why we use aggregation now
data from different sources is gathered
by an aggregation method which are then
processed to a single outcome now to
perform an aggregate function in a
relational database the database
management system typically extracts
data from multiple rows of the same
table but in a document oriented
database like mongodb the database will
gather information from various
documents in the same collection so it
basically group values from multiple
documents together to a single resultant
value now the next one is it fetches a
lot of nested data to perform complex
operations Now when using a database
management system you must run an
operation known as a query right each
time you want to retrieve data from
database however queries only return the
information that is already present in
the database you will frequently need to
carry out another type of operation
which is known as aggregation in order
to analyze your data in order to find
patterns or other information about the
data so if there are if there is a
complex operation that is needed for the
data that is present in documents you
need aggregation and finally it filters
and sort documents and analyze data
changes now uh mongodb being an SQL
nosql database the data model will
frequently change as the data that is
being you know inserting into the
database might change over the time so
in order to analyze this unstructured
data it becomes quite important that you
uh make a proper you know filtration and
sorting of these documents to get a
proper insights for your businesses and
as well as your you know requirements so
in that case aggregation can be quite
useful which simplifies you know the
complexity of the query that you have
written and fetches the data in no time
so these are some of the main reasons on
why we use aggregation
now aggregation uh in mongodb is
performed using uh aggregation pipeline
stages with consists of four different
you know methods the first one is match
next we have group Next we have sort and
finally we have project these four
combinedly are known as aggregation
pipeline stages which perform
aggregation as per the requirement now
firstly when you take a collection and
the first thing you need to is if you
want to match only certain Fields you
know within your documents to perform
aggregation then you can use the match
method next we have the group now just
like the group by clause in SQL you can
use the group uh you know function here
as well in order to group all this
similar or the related uh type of data
in your
you know pres present in your
collections that is the data that is
present in your documents to in order to
retrieve the similar kind of data you
can use the group Next sort again
sorting can be done in any other way
like from ascending order or descending
order next we have the project as we
discussed earlier in a previous tutorial
project is used to uh you know remove
the unnecessary fields that you want in
a result instead and finally after you
know matching all the four uh pipeline
stages then you get the resultant output
so let us understand this uh with an
example wherein we'll discuss how
aggregation Works in mongodb now as
discussed earlier the firstly the match
condition uh you know specifies only the
related documents that you want to
consider so for example I have a
collection name orders here and I'm
performing uh you know an aggregation
operation here so first I've mentioned
the match for status a so I have like
four documents here if you see in the
orders like for the four different
customer IDs we have the amount and
status now I want to retrieve only uh
those documents whose status is a so for
that I'm using the match command here so
match command only retrieve the one that
you have specified here which is data
say so we have only three records that
have the status as field and their value
is a so we have sorted initially with
the match command next we want to group
the values in the order of their let's
say IDs and then so if you look at here
we have two similar IDs which is A123
and b212 so what group does is it will
match all the similar related fields
together and produce a result so you can
see the A123 and B21 b212 are separated
into a different groups and finally what
I'm doing is I'm sorting I'm sorting and
I'm applying an operation here with sum
so what it does is it will basically
calculate the total amount here so if
you look at the first ID A123 the amount
is 500 and 250. so the resultant output
would be 750 and finally we have the
customer ID of p212 the amount is just
200. so in this way the aggregation
pipeline Works in a methodology of
wherein it matches the values that is
the similar values from the documents
then you can even group the data that
you want to show in a resultant output
and you can perform various operation uh
using the aggregate functions like some
minimum average with the help of sorting
as well so this is basically how
aggregation Works in mover DB so and
finally as discussed earlier just like
similar to SQL we have the same five or
the main five aggregation operations in
SQL which is the first one is sum it
basically adds up the values of every
documents of a collection next we have
the average which computes the average
value of every document of a collection
next we have minimum or Min Returns the
minimum of all values from the
collection and next we have Max which is
opposite to that of minimum minimum
which Returns the maximum of all values
from within the collection and finally
we have an additional uh you know
operation which is a push operation
since mongodb is non or relational
database we also work on the array of
elements so in order to add the values
to an array in the associated document
within a collection you can use the push
operation as well now this might be a
bit confusing for you guys now so let us
jump into mongodb shell for execution
part where it will perform uh
different operations using the
aggregation pipeline stages and see how
they are getting implemented and also
perform a detailed analysis on the uh
data uh the collection that we have and
we will bring out some inferences using
the aggregation operations using various
expressions like some average minimum
and maximum so without any further delay
let us jump into mongodb shell so as you
can see we have opened the mongodb shell
command prompt line so let us just uh
use the command show DBS to find out the
database present so we have different
databases like admin config local and
simply code one we'll use this simply
code one as usual so use
write the database name user B code one
now let us see the collections that are
present in the table so we have the
employee collection again so let us
write the command using the DB dot find
find
so it will retrieve all the values that
are present in this collection so we
have our different fields like employee
ID first name last name email phone
number hiring date job ID salary manager
ID and Department ID so all right let us
now perform the aggregate operations in
a sequential way firstly we look at the
match aggregation uh you know stage
where it will match the related fields
that we want in a result then set now
let's say if I want to match the
department ID whose all the Embers who
belong to the department added let's say
100 so in that case the following query
would be DB Dot
employee dot mention the aggregate
keyword here which is a must otherwise
it will throw an error and open the
parenthesis and mention the square
brackets and use the dollar symbol to
write the statement for match
put the call in
and open the parenthesis and mention the
department ID
field
which is uh on which we are basically
you know matching the attic watch so
mentioned it again the colon and within
single quotes mentioned the department
ID name so since we have taken as 100
I'm just taking it close the uh flower
brackets
two times and again mention the square
bracket once again and close the
parenthesis all right so this is the uh
basically the query that we have written
here which is DB dot imported Aggregate
and we're using the match aggregation
method here wherein we are matching all
the records of the employees whose
Department ID belongs to 100 so let's
now enter
uh I think there is an error here
so we had a error in the syntax guys uh
so as you can see in the output we can
see only those records of the employees
wherein it is showing are the records
whose Department ID is hundred so we
have the employee ID 108 109 110 111 and
112 113 and all of them have their
employee Department ideas sorry or
Department IDs 100
so I hope you understood this so let us
now uh go through the next stage of
aggregation Pipeline with valentail
group uh the values now so for that the
following query would be DB dot employee
dot aggregate
which is the keyword again open the
parenthesis
and mention the double
square brackets open the flower brackets
and use the dollar symbol again write
the group keyword
and open the flower brackets again
and mention the ID here so I'll explain
why we are taking this here again
so firstly let us just write the you
know command and then I'll explain to
you guys that why we are implementing
that so I want to group all the
basically the department IDs right so I
am taking Department ID
so mention the dollar symbol
which is the field name which is the
department ID
close the
flower brackets twice mentioned uh a
double bracket square bracket as well
so when you enter uh you can see the
list of all the department IDs that are
present in our collection so we have
various I uh Department IDs like 60 10
30 70 40 110 115 20 98 and so on
so now you might have a doubt that why
we are using the ID field layer now we
are using the group stage to group the
input documents by the specified you
know ID expression which returns a
single document containing the all the
cumulative values of all the ER
Department IDs that we have taken here
so in this above example only the group
stage is specified in the pipeline
whereas the group uses the ID field to
calculate at the value for all the input
documents as a whole so the expression
ID column uh
the dollar symbol Department ID creates
a distinct group on the field Department
name since we don't uh we didn't
calculate any accumulated values in our
document it Returns the distinct values
of Department IDs that are present in
the table or in a document so in this
way you can use the group aggregation
method as well
so this is how you can use the match and
group stages where you can combine both
these as well so next let us look at how
to create an aggregation operation using
one of the expression that we have like
count average sum or minimum now let's
say if I want to count the total
employees in a particular Department in
that case I'll basically use the match
statement wherein it will group all the
values of the employees whose Department
IDs in a particular you know value and
then it will count the total number of
employees in that group so for that the
following query would be DB Dot
employee Dot
aggregate
open the
open the brackets and
square brackets as well and then mention
the flower back brackets and then use
the dollar match group stage
wherein we are matching uh you know
the department ID let's say Department
ID of 60. so in that case it would be
Department
ID
I have taken the value as 60 mentioned
in the double coach
and close the brackets
put a comma and then basically we are
counting right so I'll use the count
function here
so put the dollar sign
and check the account keyword
and let's say
the statement would be total
employees
in Department
60.
right so
mention the put these close the uh
brackets as well
square brackets second
so when you press the enter in a
resultant output it states that total
employees and Department 60 is 5. so
similarly you can check for various
other departments as well so let us just
verify if it's showing correctly or not
I'll just copy paste this and let's say
for 100 now I want the total number of
employees present in the uh Department
100 so in that case I'll just mention it
I'll just change the values and let us
now print the enter so as you can see in
the resultant set or the result in the
output you can see the total number of
employees and Department 100 is 6.
wherein we have the total number of
employees in Department six days five so
in this way you can use the various
aggregation stages using the match group
and as well as sort as well and perform
various aggregation operations like Sim
uh some minimum maximum as well
so I think we have covered most of the
concepts that we have discussed in our
Renault tutorial so that brings us to
the end of today's session guys I hope
you understood uh what aggregation
methods and how they are used in mongodb
so let us understand what is mongodb
replication now the database application
is the process of copying data from a
database in one server to a database in
another one ensuring that the same data
is available on more than one mongodb
server now the main purpose of
replication is high availability and
data redundancy now data is kept durable
by having several copies or replicas
stored on physically separate servers
now replication is that process of
generating redundant data in order to
integrate and protect data accessibility
and durability
Now by generating multiple copies of
your data across servers replication
enables you to increase data
availability this is especially helpful
if a server fails or your service is
interrupted or if there are any hardware
failure issues
now if your data is only stored in a
single database any of these events
would make data access impossible so if
there is any breakage or failure of
system or server failure in that case
you need a recovery and backup option
however thanks to replication your
application can remain operational even
if your database server fails while also
providing disaster recovery and backup
options as well so that is what mover DB
replication is all about now why we need
replication in mongodb now there are
various factors that we can take into
account on why we need replication but
these are the main reasons why we need
replication now the first one is
replication provides High availability
of data now as discussed earlier the
main purpose of replication is to
provide High availability and data
redundancy by storing the data in
multiple server rather than one now this
data is available 24x7 to the user even
if there are any issues with the uh you
know server side or any database failure
as well now it also protects from any
single server loss or Hardware failures
and service interruptions so now data
replication is much to keep your data
protected right so it ensures not only
the high availability of data but also
the ease of access especially in the
event of any unexpected errors such as a
system crash Hardware or software based
errors and Etc and finally replication
ensures that data is always available to
every client now no matter the problem
is the report replication it does is it
basically shifts the data into multiple
uh servers or multiple locations wherein
the data can be available in each of any
server that is present in the database
rather than only a single server side
where the data is stored so let us now
understand how does replication work in
mongodb now this diagram of mongodb
replication is shown in the image which
I guess you guys are visible where a
client application always communicates
is the primary node and the primary node
replicates the data to the multiple
second denotes here so we have a client
application wherein the data that is
being read and write operations are
taking place from mongodb server and the
driver as well and we have a primary
server here which basically does only
write operation right and rate operation
both as well and then from there it
creates a replication of the same
database server into a secondary server
now when I talk about server here we
have different nodes now replication you
know is done through a replica replica
set process which in simple words it's a
group of mongodb process to keep the
same data across different servers now
we'll be discussing what replicate set
is in a while so but a replicates it
basically you must have certain number
of nodes now as you can see in the right
side of the image we have various
multiple nodes that is servers now in
that we have we need at least one
primary server in order to perform
replication on the data that is present
in a database the rest all can be
secondary data now a replica set must
have three nodes at least now one of
them must be primary and the rest
secondary ones our application structure
can have up to almost 50 nodes so let us
now understand what is replicated that
we have been talking about now mongodb
manages replication using replica sets
which are collection of related mongodb
nodes now a replica set requires a
minimum of basically three mongodb nodes
that I have discussed earlier one of
which should be considered as the
primary node that receives all the right
operations and on the other hand the the
rest of the remaining ones are
considered as the secondary nodes which
will replicate the data from the primary
node and if in case if there is a
failure at any level of uh you know node
structure or if if there is any
possibility of a field known as
recovered it actually works as a
secondary node again but not as a
primary node so if you look at this
diagram again here now basically we have
an application and then we have a
primary node here right now the primary
uh node is the member in which the
replica set receives write and read
operations but read operations can be
pointed out to secondary notes as well
which changing the configuration at the
moment to perform the query besides the
replica Set uh we can have only one
primary node at most as discussed
earlier and then the replication is done
on the secondary node so the secondary
uh node is where the data is replicated
to maintain a copy a replica set can
have one or more secondary nodes here
guys so basically the clients cannot
write data to secondary ones only they
can read from them that is what a
replicate set is all about so let us
just quickly recap what we have covered
here not to perform this we need a
minimum of three nodes which is required
and in this operation of replication
mongodb assumes one node as one of one
one of the replicates it as a primary
node and the remaining as the secondary
node so from within the primary node
data data gets replicated to secondary
node and again in case of any failure or
any system error the new primary nodes
get elected in case there is an
automatic maintenance or failover now if
you can see in the second diagram we
have a hard symbol here guys which is
basically known as heartbeat mechanism
so each node is connected to all the
other and a heartbeat mechanism is in
place to call any other node so the
heartbeat has a configurable time for
pinging the nodes and the default is 10
seconds so if all the notes respond with
an acknowledge to the heartbeat the
cluster or the server the the nodes
where the the nodes are present it
continues to work and if one of the
nodes crashes the primary node for
example an election takes place
involving the remaining nodes and when a
second it does a second you know doesn't
receive a response to the heartbeats up
to the configure timeout it calls for an
election so this takes place until the
primary node which has been failed is
recovered so next let us discuss what
are some of the benefits of replication
now as discussed earlier replication
helps in disaster recovery and backup of
data it basically improves application
reliability Now by spreading your data
across multiple machines you can ensure
that your applications data continues to
be available even in the event of any
hardware failure on any given machine or
server in the replication group it also
uh the replication also minimizes
downtime for maintenance now since we
are you know transferring or locating
our data into various multiple servers
it basically minimizes the downtime for
maintenance also and we can also achieve
load balancing as well using a
replication we know that mongodb works
on a lot of unstructured data and it
keeps on piling up on and on so if let's
say if a user is working on one of the
database and which is having a
particular server to its name while a
lot of people also can work on the same
server so that can cause you know a
breakage of failure sometimes so so in
order to achieve that load balance you
know to handle number of people and
number of people that are working on the
same database we can basically replicate
the data that is present in our database
to different servers and from which we
can eventually achieve load balancing
now on the other side we have certain
limitations as well with the usage of
replication also some of them are higher
cost and time constraints now
maintaining consistent data across you
know disparate all various locations
option taxing in terms of resources now
if you maintain duplicates of the same
data in various locations and
distributed database systems which
results in great greater storage as well
as processing costs as well which
ultimately results in time constraints
while executing and handling the
duplication process which needs
committed time from an in-house team or
a people that are working on that
database to ensure that the copy data is
consistent with the source data that is
all the data that is being copied from
the primary node is actually same as
that is being copied into the secondary
node and finally redundant data is being
stored in the secondary uh server or
secondary node right so it basically
takes more space and server processing
is also required which takes a lot of
time so those were some of the
limitations or you can say disadvantages
of a replication in mongodb and that
brings us to the end of today's session
guys uh so let's just quickly recap what
we have discussed in the uh today's
session now mongodb replication is one
of an important process which makes data
available across multiple data servers
so instead of just storing our data at a
one particular site you can basically
shift into across multiple data storage
locations now data redundancy and
availability and load balancing are one
of the important factors that we've
discussed in replication which are
important you know for maintaining such
a huge database you know data that is
being constantly changing and ever
evolving mongodb also supports
application with the help of replica
sets as discussed replica sets are
basically a combination of various
mongodb instances each having a single
primary node and multiple secondary node
now this process is done on a keyword
that is heartbeat mechanism which is a
method of finding out the current state
of the mongodb node in a replica set now
the heartbeat signal basically matches
or verifies whether the data is being
generated in the primary node and it is
further uh displacing into this
secondary node so replicate set
selection is used to find out which
mongodb node should be the primary node
and finally we talk about scalability
performance and high availability which
are the Paramount factors in mongodb
replication now when I talk about
scalability guys scalability as the data
volume increases the complexity of
accessing data and working with data
also increases so the replication in
place multiple data copies are available
users to not only increase their data
but also recover any previous version in
case of any errors or failure
performance is also very important when
you are replicating certain data now
when data which is available across
multiple servers it not it not only
makes accessing data easier but makes
recovering from unexpected and sudden
failures much easier so replication
basically ensures data availability and
security all the time so with
replication in place there's no need to
worry about data failures your data is
you know safely stored in other
locations so in situations where your
primary source of data fails you can
easily access the same up-to-date data
from a secondary Reserve or the data
that is stored in secondary server which
highly promotes data availability and
which is another in today's session
we'll be going through mongodb sharding
concept and we'll understand how it is
implemented the use of it and how
exactly it is performed and will finally
understand the advantages of shopping in
mongodb so without any further Ado let's
get started with today's topic
so firstly what is starting in mongodb
now sharding is a method for
Distributing a single data across
multiple databases which can then be
stored on multiple machines this allows
for large data sets to be split into
smaller chunks and stored into multiple
data nodes increasing the total storage
capacity of the system
so for example let's say I have a
database which has you know 2 million
users uh that are running on my database
frequently so the single machine has a
capacity to only uh hold two million
records in that now for instance my
business is growing and with the ever
increasing demand of data the data is
being piled up in in more uh you know
numbers now for example the 2 million
has been raised into 3 million and in
that case the operations on that
database can be quite difficult because
there is a huge traffic of data that can
be uh you know applied on that database
for in that case I can basically split
the data database into two different you
know instances where I can make two
machines or I can basically store the
data into different servers wherein I
can have two different capacities now
let's say I have divided the 2 million
to 1 million and 1 million now I further
can have a total capacity of total 4
million that is 2 million and 2 million
in each database so this is what a
sharding is based upon sharding
basically distributes the process and
stores a single data set into multiple
databases
now the purpose of any database
distribution is to enhance the
scalability of the applications uh and
sharding is an excellent way to keep the
data safe across different resources in
mongodb database sharing is an
achievable by breaking down big data
sets into simple subdivided data sets
across multiple instances now this
single database cannot handle a database
which large data sets right as it
requires large storage and bulk query
operations can use most of the CPU
Cycles which slows down the processing
of the system for six scenarios we need
more powerful system
so now one approach is to add more
capacity to single server such as adding
more memory and processing units or
adding RAM on on the single server then
it is basically known as scaling now we
can do scaling in two ways first one is
we have vertical scaling vertical
scaling basically refers to adding more
resources for example adding a new CPU
or increasing the Ram or or instead
adding a new disk size to your server
based on your demand and next we also
have horizontal scaling horizontal
scaling involves adding more and more
processing units of physical machines to
your server or databases
so it is basically used to divide a
large data set across multiple systems
and serve a data application to query
data from multiple servers this approach
is basically called as horizontal
scaling and mongodb handles horizontal
scaling through starting
now let us now understand why we exactly
need more modbs starting guys now we
learned that in our previous uh tutorial
about replication wherein we learned
that replica sets gave us the ability to
hold data in multiple databases and thus
given as a certain level of fault
tolerance and data duration and however
this approach has certain limitations as
previously mentioned guys all right
operations in replication go to the
primary nodes as you can see here we
have the primary node here it is going
to the uh secondary node and all the
right operations are basically done on
this primary node and all the read
operations are basically processed to
the secondary node which makes it the uh
you know crucial thing of any system
right the this means that if the system
grows this primary node will be overused
so in that case
eventually it will be limited with
Hardware limitations like Ram number of
CPUs and disks and Etc
so in that case it it is quite difficult
you know that a database can be of
efficient way to uh you know address the
demand or process the data within the
database so that is where mongodb
sharding comes into picture
now
since it is a limitation of uh
replication that is where as I said
sharding comes into play when there is
when database must struggle to handle
more and more data and the query traffic
increases in that case you need to
distribute the data into simpler or uh
secondary multiple machines now another
reason is mongodb instance is unable to
manage right operations as I said
earlier uh the database in replication
you know you're basically copying or
duplicating the data from one uh the
mongodb database into another in that
case it becomes difficult for one single
database to manage all the right
operations right so in that case we need
sharding
next memory cannot be outsized enough in
case your La if your data set is large
for example if the Earth the database is
working on large data large data sets in
that case memory cannot be you know over
uh settled or you can incorporate a
memory you know if the data data set is
too large
and finally which also impacts the
database maintenance also and vertical
scaling is nowadays too costly and in
that case mongodb sharding comes into
picture
so that those were some of the reasons
why we need mongodb shading so let us
now move ahead and let us understand how
mongodb sharding works now before
mongodb sharding uh the working of
mongodb sharding we need to understand
the mongodb starting architecture now
implementing the concept of sharding can
be done with the user's clusters so when
I say about clusters sharding clusters
are basically the combination of
multiple shots Mongoose processes and
configuration servers so if you look
into this image we basically have an app
server wherein we have various routers
and we have a mongodb mongoose instance
of mongodb mongos process and we also
have configuration servers or config
servers which are basically the replica
sets and we have different shots where
we are basically trying to you know
breakdown uh a single huge uh database
into further uh you know shots or
simpler pieces
now this is done with the help of a
sharing key now on charting a mongodb
data set a short key is automatically
created by default the short key
basically can be in form of an indexed
field or index compound field that will
be used to distribute that data among
the charts generally The Shard key is
used to distribute mongodb collections
document across all the shots where the
key consists of a single field or
multiple fields in every document
so that brings us to the main part which
is how mongodb chatting works now now
mongodb sharding works by creating a
cluster of all these mongodb instances
consisting of at least three servers
which we'll be discussing in a while so
the shared cluster or the mongodb
sharding cluster consists of three main
components which is basically shot
mongos and config servers now when I
talk about chart a chart is basically a
single mongodb instance that holds a
subset of the sharded data charts can be
deployed as a replica set to increase
availability and provide redundancy now
the combination of multiple charts
creates a complete data set for example
if you're trying to break down or let's
say a 5tb data set which can be broken
down further
into four shots each combining of 100 GB
of data from the original data set so
that is what A Shard is all about now
next we have mongos Mongoose acts as a
query router providing a stable
interface between the application and
the sharded cluster the this mongodb
instance is responsible for routing the
client's request to the correct shot and
finally we have the config servers
configuration servers basically restore
the data and the configuration settings
for the whole cluster so if you look at
it look at this diagram we have a router
which is having a mongodb instance and
we have configuration servers wherein we
have primary secondary servers in that
and also we have shards where we are
basically dividing again into primary
and secondary so the application
communicates with the routers which is
basically the Mongoose about the query
to be executed now the Mongoose instance
consults the config servers to check
which chart contains the required data
set to send the query to that chart and
finally the result of this query will be
returned to the application
so you need to understand that it's
important to remember that the config
servers also work as a replica sets here
that is why we have primary and
secondary uh you know nodes here as well
so this is how basically uh how mongodb
sharding works now the idea is to have
basically multiple replica sets with
multiple primaries that will divide data
and load it among themselves and each of
these replica sets is basically called A
Shard but multiple shards are not enough
to achieve the proper functionality of
this kind of system
so and that brings us to the final
component or final uh you know thing to
our session which is basically the
advantages of sharding
so in database sharding the gives a lot
of advantages now one of them is
increased storage capacity so when data
gets distributed across the shards in
the cluster each chart contains a subset
of the total data in the cluster and on
increasing the data volume the
additional shards grow which leads to
expanding the cluster storage capacity
sharding also increases the read and
write throughput in the database also
guys now in mongodb the read and write
workloads are easily distributed across
the shards in the sharded cluster it
allows each chart to process a subset of
the cluster operation so both the read
and write performance can be directly
scaled horizontally across the cluster
by increasing the short count and which
again ultimately results in high
availability of data now with an
Uncharted database an outage in one
database chart has a caliber to their
you know impact the entire application
and lose losing its functionality or
even completely stop it however with a
sharded database if there is complete
unavailability of one or more sharp
replicas only a few parts of the
application are the website which is
available to some users however the
other shots continue their operation
without any concern and finally sharding
facility facilitates horizontal scaling
now one more reason uh you know
developers love database sharding is
that it facilitates horizontal scaling
which also means scaling out your
databases this means it allows you to
have parallel backends and Carry Out
tasks simultaneously without no with no
hassle whether the focus is on writing
or reading operations scaling out can
add big advantage to enhance the
performance and also eliminate
complexities so these were some of the
main advantages of sharding guys so that
brings us to the end of today's session
now you might wonder how sharding and
replication are different from each
other so whenever you're thinking about
sharding or replication you need to
think in the context of you know the
right and the update operations that
you're performing on your database so if
you don't need to scale write uh write
processes then applique then replication
as it's fairly simple is a good choice
for you on the other hand let's say you
know if your workload is mostly on right
operation uh most of the times then at
some point you'll hit a uh you know a
right operation that is compulsory
needed for you in any case right so if
right request comes
um comes then basically blocks
other right requests right so these are
all the right request blocks until the
first request will be done so if you
want to scale this right operations and
want to paralyze then in your in in such
case you need to implement sharding what
are relationships in mongodb the mongodb
relationships are the representation on
how different documents present in a
collection are collected logically to
each other database
relationships helps in various different
factors right for example it
relationships enforce data integrated in
relational databases and it also
establishes such a between documents
which can help refine the database
structure as per your requirement now we
know that mongodb is a low SQL database
and has a lot of unstructured data so in
order to properly confine all the
documents into a proper format and
refining them into a proper structure is
quite beneficial not just in terms of
saving the data but it also affects the
performance and makes execution time
also shorter and finally it basically
links important entities in the database
so that is what relationship and
Mobility is
now there are different types of
normative relationship here guys we have
embedded and reference method so data
relationship can be achieved through
these methods wherein embedded documents
a relationship between data is by
storing related data into a single
document structure now let's say if I
have a collection I'll have two
different documents now as the word
suggests which is embedded I am
basically storing these two different
documents into a single document
structure which is known as embedded a
document relationship and similarly we
have a document referenced method or
simply reference method which is used to
store the relationship between data by
including any links or references from
one document to another
now we will understand this with an
example here now if you consider this
embedded model uh you know collection
which I have here let's say I have uh
you know a details of a person whose
name is Prada whose ID is double one
eight zero two five his contact details
are there his phone number is email
address now this is basically one
document right now similarly I have
another document wherein I'm having his
great details that is his subject which
is cs203 and the score that is the grade
that they have achieved is B now instead
of having two different uh documents in
the collection and basically merging
them that is I'm embedding both of these
into a single document so this is what
embedded model does it basically
combines two or two uh documents into a
single document structure
and similarly I have reference model the
reference model basically links two or
more documents right now let's say I
have again a student collection here
which is uh of Rohan whose uh contact
details his email ID phone number and
grade MP displayed here so let's say I
have
uh let's open a collection
uh in that I have three different
documents which is student contact
details and grade now instead of having
three separate uh bought a three
separate documents I can simply combine
these or I can link uh with the help of
user ID I can basically come by the
contact details as well as the grade
into a single document so this is how
reference model works that is by
referencing or linking to our Word
documents into a single document
structure so that was all about
reference model and that is main
difference between mln and reference
now we have these two embedded and
document reference relationships and
these can be achieved by three different
methods that is we can have one-to-one
relationship one to many relationships
and in document reference relationship
can be achieved through many too many
relationships now let us now understand
what exactly these are all right so
one-to-one relationship basically if you
have any one field it can only have one
value in such case it will consider as
one to one relationship between any data
that is present in the document and if
you consider one to many otherwise the
name suggests one too many so when one
field has multiple relationship between
the data in between documents that is
stored in the collection of a database
in that case in such case one to many
relationship model can be used
and similarly we have many too many now
let's say I have uh
you know three uh different you know
document structures wherein I have two
or more entities within a document and
having let's say a array of uh details
present in a single collection or in a
document so it can have multiple
relationships right so in in that case
we need to use many too many I hope this
is clearly understood uh we'll get into
detail by uh each of them we will
consider each of the relationship model
and understand how it is different from
each other with an example now
so firstly we have the one-to-one
relationship guys now whatever
relationships are created by linking two
documents from different collection
using a shared key that is sharing the
object ID of one collection to the other
uh which is a property of the same value
now also the best way to create this
relationship is to have the child
collection query which is the key value
of the first collection now object IDs
which basically are created by default
in property we are commonly used to make
this connection although it can be of
any other type now let's say I have
another example here which says that I
have a user's collection which has ID by
default name John and age is 40. and I
have address collection as well which
has ID which is by default again and the
address details like street name master
street number I'm having 14 21.0 city as
neuron now what what one-to-one
relationship does is it links to
different documents right so in order to
combine these these two I need a a
common property or a common tea that is
done by using the object ID here so if
you look at the result the resultant set
of the document has been combinedly
showcasing the details of the user as
well as its address so you can clearly
see that we have the object ID the
details first here next we have the name
John 840 address again in address we are
basically documenting or adding the data
of the address in the same document
itself so this is one-to-one
relationship
let us now move ahead and understand
what is one to many relationship
so what do many relationship is another
relational model we use which is created
by linking a document in one collection
to multiple documents in other
collection so let's say I have a
you know an example of a collection here
now this is basically a widely used
either to increase is to use
increasingly and you know where there
are more array values within a table so
in such case you can you can use one to
very relationship now for example I have
a authors collection which says uh the
name of the author is JK Rowling and we
have two different books and for that we
have object IDs as well so in other
collection we have the details of the
books now clearly which is ID again a
name of the book is philosopher stone
and next we have another book collection
uh the data that is of chambers of
secret now in order to compile this now
one to value is basically with the
reference of author collection are
basically collecting uh you know two
different book collection into a single
document so we have multiple documents
in the books collection right and we
have a single author collection now I'm
basically clocking these two are
creating a link between these two
collection and I am creating a single
document so if you look at the result
resultant set I have the name of the
author that is JK Rowling and the books
are there IDs and the details of their
books that is the name that is
philosopher stone and Chambers of secret
so in this way you can also use one to
many relationship model in order to
properly structure your data based on
the requirement
and similarly we also have made too many
relationship here guys but I'm not going
to discuss it let us know in the comment
section below uh and let us know what
can be a good example of very to many
relationships and that brings us to the
end of today's session guys now while
embedded a data type uh embedded
document model is ideal for one to one
and one to manage relationship are
referenced uh data document model is
ideal for many to many relationship now
denormalization which is embedded
whereas normalization is the name given
to reference relationships now
establishing a good relationship between
documents can Aid in the refinement of
the database structure as we discussed
earlier which can overall impact uh can
impact the overall performance of the
database
reduce the execution time in the
database as well
so I hope right so what is grade Fs in
mongodb Grid FS is one of the powerful
specifications of mongodb that helps to
store and retrieve large-scale files so
it is a specification for storing and
receiving files larger than 16 MB limit
of based on documents now these files
can be structured or unstructured and
they include documents audio files
images recorded video clips binary files
Etc now gridface is similar to a file
system for the storage of files but
mongodb collections are used for storage
of data and files using grid refers
which has powerful features to store the
files of any format including files that
are even more than 16 MB in size So In
classical implementation there is a file
storage system of 16 MB but mongodb
gridfs can store and retrieve files
Beyond this limit too
now mongodb great Affairs features allow
for the storage of large files as we
discussed earlier so in order to store
very large files it is not necessary to
load the entire file into RAM instead
chunks of the files are streamed to the
database so these files can be again of
any format it can be an audio pdf movie
and then they are converted into smaller
chunks and they are streamed into the
database so each chunk is limited to 255
KB in size this means that the last
chunk is normally either equal to or
less than 255 KB so it is the checks are
partitioned into smaller 255 KB files
and when you read from grade grid FS the
driver reassembles all the chunks as per
the user's requirement when they are
needed this means that you can read
sections of a file as per your query
range such as let's say listening to a
segment of an audio file audio trying to
fetching a particular section of a image
file now because as discussed earlier
files are separated into smaller parts
it is easier to access you know specific
areas of a file which saves memory tasks
such as loading the whole file
now let us now understand why we use
grid Fs in mongodb
foreign so as discussed earlier in
mongodb we use great FS for storing
files which is which are having you know
size larger than 16 MB so in some
situations storing large files may be
more efficient in a mongodb database
than on a system level file system and
that is a reason we have uh some reasons
right a particular you know significance
of using grid f as one such reason is if
your file system limits the number of
files the current directory in the
database you can use grid FS to store as
many as files that are needed now the
second reason is when you want to access
information from portions of large files
without having to load the files into
the memory that is without calling the
whole uh you know data into the ram you
can use grid FS to recall sections only
of particular uh you know specific
sections of files without reading the
entire file into the memory and finally
if you want to store and sync files and
meta data across distributed system so
when you want to keep your files and the
data automatically synced and deployed
across a number of systems and
Facilities you can basically use grid FS
so mongodb can distribute files and
their metadata automatically to a number
of mongodb instances in the database
so these are some of the reasons on why
we use data grade FSN mongodb
so let us now move ahead and
and understand how exactly you know
grade FX Works in mongodb now grid FS
stores files into two collection now
these two collections are basically
known as chunks and files chunks
basically stores the binary chunks and
whereas the files store the files
metadata so if you look at this diagram
which we have uh in our presentation
that you are looking at we have let's
say a large file it can be an audio it
can be a video file or anything and
let's say we have we are dividing we are
using grid Fs in order to uh you know
convert into a chunk of files now when
you are basically converting into a
chunk of file it basically converts into
file metadata and the smaller segments
of data which we call as chunks so we
have fs.files collection fs.chunks
collection so basically grid FX stores
files in two collections right now
it places the collection in a common
bucket so you can see we have FS bucket
which comprises of FS dot files and Fs
dot collection so it places the
collection in a common bucket by
prefixing each with the bucket name so
by default grade FS uses to collection
as you can see which is fs.files and Fs
dot collection you can choose a
different bucket name as well as create
multiple buckets in a single database
now the full collection name which
includes a bucket name is subjected to
your requirement and your and the need
of the uh
file that you're working on
so let us now understand what is grid FS
chunks collection now the each document
in the check collection represents a
distinct chunk of a file which is up a
smaller segment of the initial or the
original file
which represents a distinct chunk of a
file as represented in Grid FX so the
syntax office I wouldn't say it is uh it
has a syntax uh the basically it stores
the data in a format of ID files ID in
and data so basically a document from
the chunk collection contains these
following Fields now the chunk ID it is
basically the unique object ID of the
chunk now just like how when we store a
data it automatically creates a default
identity database similar for grade FS
also we have an ID that is being
automatically generated next we have the
chunks.files ID now this is basically
the ID of the parent document as
specified in the files document next we
have in now chunks Dot N basically is a
sequence number of the chunk that is
being you know stored into the
collection now grid FS numbers have
chunk numbers starting with 0 and so on
and finally we have Chang dot data it is
basically
we know the data that it gives a
different serial number to the data that
we have inserted into our based on
document
next we have the grid FS chunks
collection
foreign
files collection right now we have
discussed what is you know chunk
collection now next we have the files
collection now each document in the file
correct represents a file in a grid
reference and similarly just like the
chunk collection we also have you know a
format and different fields uh you know
when we try to store uh collection grid
access you know collections in our
database so
some of the fields that are we that are
present in the collection are ID length
chunk size upload date file name content
type aliases and metadata so documents
in the file collection contain uh these
following Fields now for example the ID
again the it is the unique identifier
for this document and the ID of the data
type chooses for the original document
next we have the length which is
basically the size of the document in
bytes next we have the chunk size which
is basically the size of each Chunk in
bytes now basically grid FS divides the
document into chunk size of uh you know
as discussed earlier it is default 255
KB each next we also have upload date
which is the date the document was first
taught by the grid refers and next we
have the content type
it is basically uh the type of you know
file that you're basically adding to uh
you know database to store information
related to the type of data phase files
and we also have optional uh field like
las's and we also finally have metadata
which is an optional field which may be
of any data type and can hold any
additional information you want to store
so I hope you understood what is greater
phase and what how it actually performs
what are chunks and how it is dividing
into sub you know segments like you know
chunks and files so let us now get you
to the direct execution part and see how
it gets executed
now now other than the theory of what uh
you know grade fsues it is also
important to understand how we can use
grid FS to store large files and we have
to uh remember that is the syntax is an
important aspect of executing the
greater facility mongodb so the one
thing that you have to remember is uh in
order to query or to insert a file into
grid FS it is not executed through
mongodb shell guys but it instead of uh
you can use you know windows or Linux or
Mac command prompt now before doing that
also you need to basically download some
you know mongodb database tools which
I'll be showing now so if you are using
Windows just uh go to Google and type
mongodb
database tools
all right
now when you scroll down a bit you will
have this you know download mongodb
command line database tools click on
that
now after clicking that you will be you
know redirected to another page which is
basically the mongodb database tool
documentation which will basically show
everything about uh you know various
database tools that are available so on
the left side you can see various
database tools like mongodum store
based on Dom Bongo import export and so
on now we are concerned with files
which is the database tool which we're
going to use in order to store you know
data through uh you know greater fills
so just click on that and if you want to
just go and understand what files
is you can just read it a bit uh so just
click on installation here it will
redirect to the installation page now
you have three options for Linux Mac OS
Windows click on installing the database
tools on Windows and uh
so it will basically tell you what all
to do here installation process it can
be installed with an MSR installer or
download as a zip archive select the
Tablo depending on a design installation
method so we'll be basically using the
MSI installer only so open the mobile DB
download Center here
so I've already downloaded it on my
system so I'm just basically showing you
again what uh on how you can install
this click on download it's basically it
shows the version again just install the
latest version platform as Windows and
the package is a zip folder click on
download it will take some time based
upon your you know internet speed it
will just take some time so wait for it
now once you are done just extract the
file
now as you can see we have a folder
which is a mongodb database tools and
inside that you have a folder named bin
open on that now as you can see we have
the list of all databases that we have
we're not downloaded successfully now we
are only concerned with mongodb files
right so just copy paste this and now
what you have to do is go to the C drive
where mongodb is installed it is
basically in program files click on
program files search for mongodb
click on server 6.0 and you'll find the
bin folder click on that and just
basically paste the whole folder or the
 files here so as you can see I've
already paid uh you know copy pasted the
same in my uh Bin folder here so just
click on that and again you'll be
redirected to bin here click on that
again so you can see we have the list of
all the uh database tools that we have
installed on our system so this is
basically the location where you have to
uh you know copy uh the entire files
otherwise it will throw an error right
so we have mongod file
successfully installed here let us now
uh try to understand how to insert a
file you know with a simple example so
you can see I have uh you know a PNG
file which is an image which is uh
document one we also have a video file
which is mp4 file which is mongodb
replication it says right so let us now
uh try to insert into uh
our database for that just click on
write right click in the same folder you
will find open in terminal click on that
so it will open the windows partial
this is where you have to write the
command prompt line all right so the
above syntax the syntax that you have to
write for this is basically by using the
put keyword which I'll be showing you
now
so we'll be just experimenting with one
simple example that F10 with a simple
image file that we are going to insert
now uh as you can see we don't have any
specific collection for grid FS files
but as we know mongodb has this feature
of creating new collection when we
insert a document into a non-existing
collection so the following query for
inserting a file in Grid FS unlike the
insert operation where we'll insert file
through shell right here we'll use
the again the window partial terminal
now the query to insert uh data
into our database is mention the
files
 files is the keyword and after
that put mention the file name now the
file name that we have taken is document
one right so mention document one dot
and this file type which is of jpg
so the above carries basically this
query is a standard format for inserting
any file into great effects We have
basically navigated the terminal to the
location where files which is a
database Tool uh is being saved so our
query begins with the keyword which is
 files followed by the storage
option which is put keyword and it
specifies the database where the file is
to be stored and here our database name
is name is generally named as grid FS
only and at the moment we don't have any
database with such name but it will be
created so let's just execute click on
enter
all right it is throwing an error
so as you can see it says we have an
error here it says the command
phase was not found but does exist in
the current location Windows partial
does not load commands from the current
location
instant type okay now instead of typing
 files let's just copy this and see
if it is working or not
 files again mention the keyword
put
and mention the document also
I mean the document name that we are
trying to insert which is document1 dot
jpg
all right let us now click on enter
I hope it should work now
I'm not sure
so I'm not sure why it is uh throwing an
error guys so let's just take another
example we also have mongodb one which
is working a JPG file let us try to add
that
now basically if you want to insert data
you have to store the files in this bin
folder only otherwise it will throw an
error so make sure you keep an eye on
this because uh you know adding huge
amounts of data can take a lot of time
so if you are trying to insert data
which is not specifically in this folder
then it will basically throw an error so
make sure you keep an uh an eye on that
so let's just uh try to add another
folder
dot uh so the keyword is dot under slash
 files put
the file name is mongodb one dot jpg and
semicolon
so I'll click on enter well all right as
you can see in the status it is
connected to mongodb localhost and it
has added grid file mongodb one and I
think it is successful now so let's just
go to uh you know mongodb shell now and
let us see whether or not it is created
so just
let's just go to uh let's open mongodb
shell
so as you can see the shell has started
so now in order to find uh whether or
not the grid FS file is created or not
you have to use the
db.fs.chunks.find command so we can see
all the chunks present in the FX
collection uh by using this command so
let's just try to find it so the command
is DB dot FS Dot
files dot find
so click on that so as you can see it is
retrieving the ID Len chunk size upload
date file name and the metadata which we
have discussed in the earlier I know in
the presentation slide on what are the
different fields that we get so we can
also see uh the chunks present in the
fs.collection related to the stored file
with the following code using the
document ID in this which is this this
object ID right so I'm going to use this
and try to find how many number of
chunks that it has created for this
mongodb1.jpg file so the command the
query is db.fs dot chunks dot find
and inside that open the flower package
and mention the files ID field
which which you are trying to find
okay mentioned colon
and mention this uh you know
object array that has created which is
639 and so on this I just copy paste
that and copy it here
and mentioned make sure it is on single
quotes
all right let us just close the brackets
and the flower brackets as well
okay there is an error sorry I just put
another square bracket
so I'm not sure why it is showing but uh
in in most of the cases the query will
return the number of documents that is
the whole uh you know mongodb one.jpg
file was divided into how many chunks of
data like for example 20 30 and so on so
in this way you can use grid FS to store
large amounts of files which are more
than 16 MB in size in your mongodb
database now just to cross verify uh go
to mongodb Compass and see how the data
in the uh database has been created so
you can see mongodb Compass we have a
test database that is created and we
have the fs dot chunks Dot and Fs dot
files which basically stores the
appropriate information of the uh date
the data that we have created in our
database right so you can see in FS dot
chunks we have ID files ID and 0 which
basically uh you know stores the data in
sequential manner like starting from 0 1
2 3 and so on and next in FS dot files
we also have ID length chunk size upload
date file name and metadata
so that was pretty much all about great
FSN uh mongodb I guess we have covered
almost all the concepts now grid FS is
basically a gift for developers who
wants to store huge files in mongodb so
if you are someone who is trying to uh
you know store data of audio files image
files or videos files features of more
than 16 MB which is the threshold value
of mongodb which is acceptable rate on
upper which only you can use grid
reference so in that case grid FS
storage system allows developers to
store big files and retrieve only
certain amount of those files whenever
needed and as a result grid FS is an
outstanding mongodb features that can be
used with variety of application which
makes it an extremely useful tool for
modern applications like a nosql
database like mongodb firstly let us
understand what is mongodb mapreduce map
reduce function is widely used to access
large data set into a handful of
aggregated results and mapreduce command
is used to execute this function now as
a result of this the data is
independently mapped and reduced in
different spaces before being combined
in the function and saved to the
specified new collection this map reduce
function was designed to work with large
data sets only you can perform
aggregation operations like Max sum and
average
on data using mapreduce which is similar
to that of group by nsql so it works
independently and in parallel with data
aggregation
now let us understand what are the key
parameters in mapreduce mongodb provides
a mapreduce feature for aggregation
purpose now generally there are two
phases of map reduce in the first phase
each document is processed and emits
common and redundant part of the
document to pass a unique record for the
next phase which is the map function
next we have the reduce function in this
second phase all the unique paths get
together and aggregate to produce a
single result and finally we have the
query in this we'll pass the query to
filter the result set so with the help
of mapreduce user can perform like
sorting filtering and document
modification
so let us now understand the syntax of
mapreduce
foreign
this is mention the keyword function and
again open the square flower brackets
and mention the keyword Emit and as we
already discussed that mapreduce works
on the key value pair so mentioned the
key as well as the value that you want
to uh you know perform aggregation on
the data and then we have function again
we have to mention the key and values
this is basically the reduce operation
this is the reduce function we are going
to perform here and then mention the
return keyword and the reduce function
that you are going to perform it can be
you know any aggregation uh you know
processing it can be average sum or
maximum and inside that we have uh
certain keywords like out query sort and
limit so basically if I look if you look
at the first part here the collection
name it is basically defined as the
retrieved documents from The Collection
by using the map reduce command so we
can process large volumes of data using
this map reduce method in mongodb so
next we have the map reduce keyword it
is basically a data processing technique
which is used for large data and useful
aggregated results of large data in
mongodb and next we have this first part
is the map function guys and next we
have the reduce function in this you
will get a clear-cut idea on when we get
to the execution part so just have an
idea on what exactly we are doing here
so next we have the out keyword here out
is basically specifies the that result
location of the map that is operation in
mongodb and we can set output as a
primary member and on the second
remember we can only set an you know
output for this next we have query query
defines the as the selection of
selection criteria of a document in
mongodb
so you are basically telling uh the uh
you know operation basically on the you
are filtering the data on which you want
to perform aggregation and next we have
an optional uh you know commands like
sort and limit as you know sort is used
to sort the documents from collection
this option is mainly useful for
optimization and also next we have limit
limit is a specified method that limits
the total number of documents in the
resulted output so I hope you understood
the basic syntax of map reduce model
so let us now go ahead and understand
how does mongodb map reduce works now
every input document in the map reduce
operation gets the map phase treatment
from mongodb that is documents in the
collection that match the query
condition so key value pairs are output
by the mapping function now this map
function is used to group all the data
based on the key value and next we have
the reduce function reduce function is
used to perform operations on the map
data so that data independently is
mapped and reduced in different spaces
and then combined together in the
function and the result will save to the
specified new collection so the reduce
phase which gathers and condenses the
aggregated data is used by mongodb for
keys that have multiple values and the
outcomes
are then kept by mongodb in a collection
so in a nutshell if I have to tell that
basically you have to mention the
mapping function first you have to
Define mapping function next you have to
define the reduce function to further
condense or process the aggregation
result now the output of the reduction
reduce function could opt optionally go
through a finalize uh you know function
wherein you are performing the complete
you know map reduce function
so let us just understand this with a
simple example here
so let's say I have certain collections
uh named as orders as you can see on the
left side we have four different orders
having customer ID amount status so we
have uh let's say I think we have two
different uh unique customer IDs which
is A123 and b212 now I'm basically
querying this based on the status that
is a and
d right so it is querying and it is
filtering the records based on this so
you can see A123
amount 500 status a next we have again
which is A123 amount 250 which is status
a again
and we also have A123 but the status is
D so it is not considering into the into
a resultant equation and also we have
this b212 which amounts 200 and the
status is a so the query is basically
filtering the resultant set in our
output next we are basically mapping the
function we are mapping based on the
customer ID here so we have two
different uh customer IDs which is A123
and b212 so we are and then we are
performing the reduce function based on
the amount right so it is
reducing the value into uh A1 to 3 and
B2 Y2 two values that is 500 and 250 for
B to 12 it's only 200. so finally if we
look at the output we are performing a
sum aggregation here and you can see in
the final resultant output are uh you
know uh document which we have saved in
a new collection is being retrieved as
ID A123 value is 750 that is 500 plus
250 and also b212 which is value 200
which are which are saving in a new
collection name order totals so this is
how exactly map reduce work which is
again a similar to that of aggregation
you know pipeline method uh I'll let you
know what exactly uh you know how map
reduces different from aggregation
Pipeline and when you should be using
which method now before going to uh into
that let us go into the execution part
and see how a mapreduce Works in mongodb
Shell
so as you can see mongodb shell has
started so firstly let us
see the databases for that I'm using the
show DPS command so again we'll be using
the same simply code database so use
and click code one
and let us now see what are the
collections present at this database so
it will list all the different
collections present to this uh I mean
documents that are present in this
collection so we'll be using a marks uh
you know collection uh for this uh to
perform map reduce so let me just uh
retrieve the values that are present in
this so DB dot marks dot find
enter it will retrieve all the records
so as you can see we have uh various
Fields like ID name subject and marks so
we have like id101 name Ravi maths 94
and similarly we have different subjects
like Science History maths uh English
and so on so we'll be performing map
reduce on this collection and see how it
how it exactly
now what we're going to do is we have to
apply a map reduce operation to this Max
collection to group them by uh let's say
subject and then add the marks code in
each subject so to process this each
input document we have to define the map
function first this map function
basically refers to the document that
the map reduce operation is processing
in that function and for each document
the function Maps the marks field to the
subject and outputs the marks and the
both subject and marks together so let's
understand how to write the how to
define the map function first and the
query is written as where and mention
any keyword here it can be a map here or
you can even keep it as mapping function
mapping function one you can Define as
per your own choice equals to mention
the function keyword
close the square brackets open the
square flower brackets and mention the
keyword emit
and in that we have to write the
function which is used with this dot so
we are performing aggregation on subject
and marks right so we have to mention
these two parameters here so mention
subject comma this dot marks close the
square brackets flower brackets and
mention the semicolon and press enter
all right we have now defined the
mapping from function first so next we
have to uh Define the reduce function so
the reduce function uh syntax is also
similar mentioned where again mentioned
the uh param I mean the function name as
per your own choice I'm just taking here
it is reduce
equals to
mention the function keyword again
and you have to pass two parameters here
since you have passed subjective marks
for our you know aggregation function so
just pass any two values it can be of
any name it can you can take it as key
and value or you can even use subject or
mugs so I'm just using the subject and
marks again here subject comma
marks
and mention the open flower brackets and
you have to return this parameter right
you have to return this function now I
want to perform let's say uh the
aggregation operation like let's say sum
so I'll write array Dot since it is uh
a document and we have various Fields
I'm just writing the array here array
dot sum and inside that mention the
parameter which you are performing are
the summation which is basically marks
right so just close the brackets and
close the flower brackets as well and
enter all right now we have also defined
the radius function now we are left with
only map reduce uh operation right so
let us now perform the map radius
operation so the symmax for that is DP
dot mention the collection name that is
marks which we have taken mention the
map reduce keyword make sure that R in
reduces in capital letters otherwise it
will throw an error and in that pass the
uh both mapping and reduce function
names that you have taken so we have
taken it as map
comma
reduce so it can be any name that you
have chosen it can be like mapping
function one or as I've said earlier it
can be any name but make sure you're
passing the same value that you have
taken and mention the comma again
and in the flower brackets now we have
to mention the keyword out as we
discussed in our syntax previously and
now we can give any uh you know
collection name you know to your output
resultant set it can be of any choice so
I'm just naming it as the result here
I think it will be good to go so let me
just execute the statement
all right uh
it is throwing an error
collection not map it is a deprecated
user aggregation instead okay I'm not
sure why it is uh showing that but we
can say result it is saying OK one that
means it has been successfully executed
so let us now and uh see whether whether
or not the aggregation function that is
summation has been performed or data set
or not
so for that I'm again using the find
command DB dot mention the uh collection
name that you have mentioned inside the
parameter and map reduce operation DB
dot result Dot
find enter
as you can see we have total four
subjects and the summation values are
showing as 93 96 I'm not sure why uh it
should perform the summation operation
so let's just check for history we have
93 and first again mine to fix all right
so it is showing simultaneous I mean
side by side it shouldn't be like that
I'm not sure why it is uh showing in
this way
so let's just try to perform another
operation and see whether it is
showing for them as well I'm just
performing an average uh you know
operation here
all right let me just check okay we have
that password and let me just uh perform
the map reduce function as well
just copy paste this and you can
let's change the name as result one okay
and click enter I think it's created so
let us find again DB Dot
uh which is again Result One Dot find
well I think uh there is some issue with
the back end of the mongodb database I'm
not sure why it is uh throwing an error
like this because average value should
be like uh this average of 40 let's say
93 96 right 49 and 47 it's showing in a
different way for maths it's 98 so it's
average it's 49 and for uh 94 it's 47
and the combined value we have to get
but I'm not sure why it is uh throwing
that error
so we'll get back to you guys uh but the
syntax and the execution is uh the same
you I think there is no mistake in the
uh syntax that you have written here it
is same there might be some issue with
the back end so we'll just get back to
you uh again so stay tuned for that
and well I think that's all about map
radios we have discussed almost
everything uh you know what map reduces
it's syntax how it works and how uh you
know how it is used you know instead of
aggregation
foreign
and that brings us to the main question
on you know which method you have to be
using whether it's aggregation pipeline
method or it is mapreduce you know
function now complex queries are
difficult to handle in aggregation
framework it can be useful but I would
say it is not recommended for complex
queries whereas if you take small data
sets small data sets will take a long
time to load and map reduce and even
large data sets will take the same
amount of time to process now whether or
not the data set is small or large it
will take the same amount of time to
execute so as a result large data sets
should be handled using the map reduce
functions always and it is a recommended
option the map reduce function can
handle you know large data sets more
quickly due to its uh maybe it's its
flexibility over you know large data
sets so you can always use this uh while
you're you know handling large volumes
of data and on the other side you can
use the aggregation pipeline to handle
small data sets you know for a regular
usage when you're performing small
calculations that is present in your you
know documents that is present in your
collections I would say so this is how
uh both aggregation and mapreduce are
different from each other and when you
have to use them and I hope you
understood that as well as you know that
mongodb relationship represents how
multiple documents are logically
connected to each other in mongodb it
provides two types of relationships
namely embedded and referenced embedded
documents capture relationship between
data by storing related data in a single
document structure on the other hand
reference models store the relationship
between data by including links or
references from one document to another
now to implement a normalized database
structure in mongodb we use the concept
of reference relationship that is if you
look at the left side of the screen here
you can have an example where it is a
reference model where we have student
collection and inside we have ID and
then we have another uh you know
document contact details where we are
referencing using this student document
right so in that way we can use
reference model for that so we use this
concept of reference relationship also
referred to as manual or references in
which we manually store the reference
document ID inside another document now
what if the data that you're trying to
search isn't present in different
collection or in different database and
that's where you have to use dbrevs
dbrevs are references from one document
to another using the value of the first
document ID field collection name and
optionally its database DBS basically
allow you to uh more easily reference
documents stored in multiple collections
or database so if you look at this
example I have a user collection here
and a post collection here in the user
collection I have ID name post as my
fields and I'm trying to
fetch those from the post collection
which is another collection in in that
case right so if I'm trying to retrieve
data from another collection which may
be present in another database in such
case you have to reference the database
that you are trying to search for and
that is where we use dbref so and that
will bring us to the main part what is
you know mongodb database references
mongodb database references allow you to
more easily reference documents stored
in multiple collections or database so
relationship between documents can be
represented using this a DB reps which
offer a standard format and type so if a
database needs to communicate with a
variety of Frameworks and tools present
in mongodb Database The dbre Format
offers common links for representing the
data between the documents however in
cases where a document contains
references from different collections in
that case we have to use mongodb ddrefs
so it basically represents a document
rather than a specific reference type
and if you're trying to find data in
more than one collection in such case
you have to use mongodb database
references all right I hope you
understood what it is and let us now
move ahead and understand uh the various
parameters that we use you know while
writing you know database reference
syntax first we have the dollar ref
keyword now ref field basically holds
the name of the collection whereas where
the reference document resides next we
have the ID field the ID field basically
contains the value of the ID field in
the reference document and finally we
have the optional DB which contains the
name of the database where the document
or the reference document resides so in
mongodb these are the three important
fields which should be used in order to
implement dbreps relationship as follows
let us now understand the syntax of
mongodb database reference and how it is
exactly used now let's say if I have an
address collection here which I'm
basically creating two different fields
which is ID and City so the command is
the DB dot address dot insert and it is
145 and city is Bengaluru next we have
another document which is DV dot address
dot insert which is the idea is 124 city
is Delhi so firstly we have inserted two
documents in our address collection now
let us move ahead and see
and how we can implement this using
another uh you know collection which is
which might be present in different
database now let's say if I have another
student collection and I mean that I'm
inserting records wherein I am inserting
records of uh student details like ID
I'm providing as one is first name of
the student is Rahul here so as you can
see here inside uh you know the address
ID which is the database reference field
which is part of the document or the
collection student collection present in
this collection we are using mongodb
reference approach to refer the address
ID present in another collection which
we have taken from the address
collection here after defining three
fields which are basically ref ID and
optional DB so the RAF is basically by
providing the field which you want to
reference have a provider reference to
the collection that you are trying to
connect here so earlier we mentioned the
ID and the address in the address
collection right so I am referring to
that that's why I'm providing the
collection name as address and ID as105
and database is optional you can keep
whatever you want I am just taking
simply it as simply code one and
similarly we are again inserting another
document and again we are referencing it
with the DB ref dbrf field which is
again address ID and for reference I'm
taking again address collection and IDs
124 and DP dot simply code
now you might have a question now what
exactly and how exactly mongodb dbref
works here now the syntax is followed as
where student DB dot student dot find
one which we use in order to uh find the
data now I'm trying to search the first
name with the name of Rohan so I want to
get the details or the address of this
student whose name is Rohan so for that
I'm querying as VAR student address
equals to student dot address ID and
after that mention the syntax as DB in
the within the square brackets student
address dot dollar ref dot find ID where
student address dot ID
now what does it mean so I'm basically
connecting both the address collection
and student collection and that is what
I'm referring here student address dot
reference and student address dot ID so
in order to get the address of uh the
student Rohan you have to basically uh
provide a reference to both these uh
collections so that is what I'm doing
here so when you execute this statement
this will be the final output now for
Rohan we have uh the ID which is 145 and
his City the address is bangaluru so
this is how exactly dbref Works in
mongodb and that brings us to the end of
today's session guys in this tutorial we
have revised the concepts of data
relationships in mongodb for the with
the likes of manual references used for
data modeling in the mongodb and
compared it against the concepts of
mongodb DB reps where the former is used
when the references are to be made to
the documents present in the same
collection so you can use manual
references when you are trying to make
references in the same documents or
which are present in the same collection
and the other uh you know part which is
mongodb dbrefs approaches used by the
references are to be made to the
documents present in different
Collections and in different database
now the main question comes is why is no
longer mongodb dbf's Concepts is not
used it is deprecated uh all around the
world and it is not a suggested method
when you are trying to work on this
mongodb database and that is the reason
also mongodb documentation recommends
manual references unless you have
documents referred to in multiple
locations or the collections in a
database so when you have multiple
collections for your references to
Target we would highly recommend it's
still easier to store the object ID and
collection name in the own object
without specifying or with a special
name of dbrevs and that won't break if
someone insert the field out of the
order now already dbreps haven't been
deprecated in mongodb as such and the
functionality is unlikely to go away but
hopefully you can see there are good
reasons on why to use and how to avoid
this function that we have discussed in
this tutorial how to use covered queries
and analyze those covered queries and
the performance that it creates while
you query mongodb database so which
helps us to query data more quickly so
without any further Ado let's get
started all right now what are covered
queries now we know that in every
database including mongodb indexes play
crucial role mongodb queries are
executed more quickly when indexes are
used as you know we have discussed in
our previous tutorials on mongodb
indexing so if you haven't checked that
out make sure you check that out on our
Channel we have a dedicated playlist on
various mongodb Concepts as well wherein
we have covered mongodb indexing as well
so you make sure you check that out now
indexes basically provide users with an
efficient way of querying data so if you
ran a query to find specific document
comments let's say in a collection of
thousands or lacks of documents without
any indexes mongodb would have to search
the entire collection in order to find
the requested document in your query
however mongodb would use indexes if you
had them to reduce the number of
documents that needed to be searched in
the collection now there is an
additional you know part of indexing
that is covered queries so you've
probably heard that column indexing is
an excellent way to improve query
performance by reducing the number of
disk access that are required now
covered queries is basically a mongodb
specific application of field indexing
in which all the query columns are
already indexed now it basically avoids
collection scan just like the normal
indexing so it allows the database to
search through less document to satisfy
a query without an index mongodb has to
scan through all the documents to ensure
it has answered the query correctly now
covered queries are extremely fast
because mongodb does not have to examine
any other documents other than the ones
that have been indexed so it only
examines document in your query that you
have provided the indexing uh that you
have provided the fields that are
already indexed
and finally fetching data becomes much
faster using you know covered queries
because uh covered queries return
results from an index directly without
having to access the source document and
are therefore very efficient as well
now there are case when you have to
consider when to use covered queries now
covered queries are only used when all
the fields in the query are part of the
index so let's say if you're trying to
find uh any field in your query it
should be a part of index that you have
already created only then covered
queries can come into picture or can be
used in a more efficient way
next is all the fields returned in the
query should be off are in the same
index now it can be a composite index it
can be a multi-key index but make sure
that the fields that you're returning in
a query should be in the same index and
finally no fields in the query are equal
to null that is field value should not
be null in in such case covered queries
will not be followed
foreign
part let us just consider a simple
example on how query or covered queries
Works in mongodb so let's say I have a
collection here which has three
different documents uh of various
customers like Rahul pranav and kirti
and the orders that they have placed and
the various personal details like
address their payment mode email or the
total order items we have an array field
here wherein we are storing uh various
fields in order items like item name
like notebook paper general or postcard
and even their price and the quantity of
the items so we have three different
documents present in our collection here
now if I want to create a simple index
let's say I'm creating an index on
orders item field wherein I'm creating a
particular index on the price here so
and also payment mode I'm creating an
index so the query would be DB dot
orders.create index orders item dot
price I'm mentioning one that is in
ascending order the indexes is created
in ascending order and also for payment
mode I'm creating an index
now generally what you have to do is uh
what you do in general for indexing or
while querying your uh data that is
present in a collection is you just
mentioned the customer or let's say if
I'm trying to find the customer name
here that is Rahul if I consider this
example here it says DB dot orders dot
find customer Rahul or as item dot price
one payment code one now we are
providing the all the index field that
we have created that is audios item dot
price and payment code
but the query that I'm trying to find is
the data of customer here that is Rahul
which we have not indexed so let's say
I'm just having three uh documents here
now if there are let's say 10 000 10 000
documents that are present in collection
and maybe we have more than one Rahul in
such case it becomes difficult right
even the indexes uh is become an anomaly
here it is not as fast as what we have
thought here now instead of that I'm
just taking another query now let's say
I have created index on orders item dot
price and payment mode right now what
I'm doing is I am trying to return the
data or I'm querying for a data wherein
I'm trying to find the payment mode is
equals to card now if you locate clearly
into our you know index query that you
have created payment mode is already
included in the query Index right we
have already created earlier and I'm
trying to find it in the same way so I'm
trying to find payment Mode card which
is again already created index which is
payment mode so in that case instead of
looking through all the uh data present
in documents it will simply look at only
the ones which are already indexed and
that is the main advantage of uh you
know covered queries it returns results
from an index directly without having to
access any Source document and it can be
more efficient uh more than just
indexing right so I hope you understood
how you know covered queries are
actually working in mongodb and let's
just uh go into mongodb shell now and
get into the execution part and
understand it in a more clear way and
also finally we'll analyze you know how
this query is working and how it is
different from indexing in mongodb
so as you can see mongodb shell has
started so the First Command would be is
basically the show DBS which will allow
us to show with show all the database
that are presented on mongodb database
so we have this simply code one database
so we'll be using that only right use
simply code
so it says switch to DP we are going to
go now let us see the collections that
are present in this database so we have
different collections like collection
name employee marks and your employees
so let us just consider uh all uh I mean
a collection that we've already created
here which is employee so let's just
find the idea
details for the documents that are
present in this collection so I'm using
the V Dot employee dot find command for
that
so when you enter it will display all
the records or the documents that are
present in this collection
all right now let us now create a
covered query now creating a covered
queries similar to that of how you
create an index uh so the query would be
DB dot employee
dot create
and mention the create index keyword
make sure the is capital otherwise it
will throw an error so let's just create
a covered index on the fields let's say
we have manager ID and Department ID
right so we'll be creating uh you know
covered query that is on this two Fields
so
mention the field name that is manager
ID
keep it as one
comma and Department ID as well
as well close the brackets alert and
click enter so as you can see it says
manager ID uh the score one Department
underscore ID underscore one that means
you're successfully created you know
covered query on these two fields that
is manager ID and
Department ID so now let's query or read
data from this covered index so for that
we'll again use the find operation so
let's say I'm trying to find you know a
particular manager ID details right so
let's say I want to try find the details
of employees whose manager ID is 123 in
such case I'll use a query that is
DB Dot
employee Dot
find
and inside the brackets let's say
manager
ID
is 123 that I am going to search for
close the brackets and mention the
indexes that you have created here
which is again manage your ID
which is one
comma Department ID
which is again one here
close the brackets I think we are good
to go
so click on enter
so as you can see in the above query
when we find document where we are
trying to find manager ID which is 123
covered index which is on manager ID as
well as Department ID is already loaded
into the RAM and as we know that
so as we know that manager ID is already
present in a compound index that is why
it reads very quickly and we avoid
scanning of too many documents in
database so this is just a basic example
on how to create a covered query so
let's just create a you know another
field where we understand how covered
query exactly works now let's say I'm
trying to create an index on the first
name let's say first name as well
so let's take
the query as DB Dot
create index
I'm just copy pasting it here and let us
create you know uh another index for our
you know collection for this so it will
be first name here all right first
name
close the brackets
so as you can see our query has been
successfully created now let's say I'm
trying to find the employee details uh
using this uh you know index that you
have created now so I'll just
so let's say I'm trying to find an
employee whose first name is Shelly Now
by default since I've created index on
manager ID as well as Department ID it
will be directly indexed and display in
a resultant set so make sure you keep
the first name field also because we
have uh created the index for that as
well
so mention first name
as one comma all right I think we are
good to go now let's just uh see the
result for this
so there was a bit error in the first
time that we are trying to retrieve uh
now Shelley which we have taken uh her
name in all caps which is not exactly
present in the same way in our you know
collection so make sure uh you keep the
name as exactly which is present in our
database which is capital S and the rest
of them are small caps here so when I
try to uh find the you know resultant
set for this the final output is the
first name which is hush name Shelly and
we are getting the manager ID as well as
the department ID that she belongs to
which is manager ID is 101 and
Department ID is 110. now if you look at
this query covered index will not be
available when you use this following
query which is DB dot employee find
first name which is Shelley and we are
mentioning the indexes that we have
created for first name manager ID
Department ID because when we find a
document where first name is Shelley
which has covered index on uh basically
the first name manager ID and the
department ID which is already loaded
into the ram but by default uh you know
underscore ID is also present here that
is the field that is not present in the
covered index is also being displayed so
despite of you know manager ID
Department ID present in our compound
index we cannot avoid scanning of too
many documents in our database so we
need to exclude uh you know underscore
ID as well if you are trying to use
covered index so make sure you include
underscore ID in your query as well
so the query now that would uh you know
followed as
with the help of uh you know indexes
that you have created make sure with the
first name keep the ID as 0 only then
who are mentioning underscore ID after
the uh Department ID
keeping it as zero so let us just find
it now so as you can see we are only
retrieving first name Shelley manager ID
and Department ID and finally underscore
ID is being eliminated or dismissed from
this
so that was all about covered index guys
now you have to remember that covered
index does not work when field on which
we're trying to cover in covered indexes
an array or an embedded document that is
when you're trying to retrieve data from
a sub document or a field that is
present in an array field in such case
covered index won't work so let us now
try to understand how to analyze this
query now the performance of indexing is
very crucial for a database performance
right so we need to understand how it is
being executed you know in the patent as
well so for that we'll use the explain
command here so for that the query is
same guys just copy paste the query that
you have uh you know created
and after that mention the explain
keyword or which is the explain command
here
so there was a bit issue or error in the
uh you know copying this code guys so
I'm just copying paste uh the query that
we have written here which is a DB dot
embroidery find first name Shelley first
name manager ID Department ID and all
the indexes that I've created on and
finally you have to mention the explain
command here now analyzing queries is
very important aspect of measuring how
well or the effective the database and
the indexing design is so for that I'm
using the explain you know command here
which basically provides information on
the query indexes that you have used you
know the performance that is the time
that it has taken to execute your query
and other statistics so it is very
helpful when analyzing how well your
indexes are optimized uh you know while
you are using an indexing or a covered
query so let's just uh see how it works
here click on enter
so you can see it is displaying all the
details of you know the performance or
the optimization of the query that has
taken place in the background here
so you can see we have various Fields
you know listed in all this here you can
see the namespace index filter set as
false and all that now we are only
concerned with here is this stage input
stage is IX scan that is index scan the
short form for this is index account so
basically that we have performed a index
scan on the query that we have uh you
know created in a resultant set so it it
basically says another condition where
you'll find this is a collection scan
that is co LLS and scan so you may find
that that is you are not providing any
index instead of finding all the
documents one by one simultaneously
using a collection scan
that is another you know scenario in
which we consider you know the type of
scanning that you have done here and you
can also see that index name that we
have created that is first name and it's
multi-key it's it's false unique false
partial false and so on so it basically
indicates the number of you know
documents that have matched that are
returned here it indicates the total
number of documents that we have scanned
and indicate the total number of
documents or index entities that we have
scanned here all this you can find using
the explain operator here firstly let us
discuss what is atomic operations in
general now in context of any database
Atomic operation means that you either
commit to the entirety of the
transaction occurring in the database or
have no transaction at all so it is
basically a complex series of database
operations in which either all or none
of the operations are being performed
while connecting any transactions or you
are trying to you know perform any
operations on your data now essentially
an atomic transaction ensures that any
comment you make finishes the entire
operation successfully or in case of any
lost connection in the middle of
operation due to power failure or any
other external uh you know factors the
database is rolled back to its state
prior to the comment being initiated so
it make sure that partial changes will
be rolled back if there is any system
failure as such now this is important
for preventing crashes or outages from
creating cases where the transaction was
partially finished to an unknown overall
State now we all know SQL provides you
know asset properties uh concept wherein
you can perform transactions on your
multiple tables right
you can perform various operations like
insert update and delete on your tables
and even if there if there is if a crash
occurs during a transaction with no
atomicity you can you can't exactly know
how far along the process was before the
transaction was interrupted but by using
atomicity you can enjoy that either the
entire transaction was done on your you
know uh table or none of it was done
so as you know it follows the various
Atomic acid properties like atomicity
which is error all the operations inside
a transaction take place or none of it
you know does take place and we have
consistency now consistency means the
data must be consisted before and after
the transaction now let's say if you are
performing a transaction from an account
a to account B for example if account a
has transferred 500 and let's say if the
account B has overall thousand in his
account now if you're performing this
transaction now after the transaction is
done the account B should have 1500
right now in case of any failure or you
know the multiple errors even after that
it must be consistent
so next that is where we have isolation
transaction gets successful in case of
system failures that is what we were
talking about no matter what the
circumstance or the deciding factor of
what has happened to your data it should
maintain consistency that is transaction
should be successful in case of any
system failures and finally we have
durability durability means changes made
to the database must be permanent now
you might work on a database wherein you
have created a temporary change but a
transaction is something which is you
know successfully happens when you are
you know making a database
changes permanently and that is what
asset properties also say that Euro
changes made to the database must be
permanent
now coming to mongodb what is atomic
operations in mongodb and how can we
achieve that foreign
now we know that mongodb does not
support transactions in a database
therefore in the application of your
database pay attention to this point
whatever the design we do not ask
mongodb to ensure data Integrity but
mongodb provides many Atomic operations
you know such as saving a document
modify update and delete as per a
requirement which are basically the
atomic operations that are done in
mongodb database so either this is the
so-called Atomic operation to save the
document to mongodb or not save anything
at all so basically mongodb maintains
atomicity by keeping all related
information in a single document which
need updation now while performing any
uh you know changes or the updation on
the documents if there is an error it
should either update all the documents
or it shouldn't update anything at all
now if you take let's say a limited
number of documents while processing
let's say I have 100 documents and I
have successfully you know updated 50
but the rest 50 are not updated and
because of some external failure or
system crash or crash failure anything
this might occur due to any external
Factor but that is not the case where we
expect our database to you know exactly
work in that way we wanted to either
update all the 100 documents or
just uh not update any of them now this
can be very useful uh and very uh I mean
becomes crucial when you're working with
large number of documents in your
collection let's say if I have 20
million uh you know such documents in my
database it becomes quite difficult
right so in that case what Atomic
operation does is it gives the related
information that you want in a single
document which is an embedded type of
document that saves all your data
now there are some constraints you know
that we have previously discussed that
you know for a database or a nosql
database like mongodb Atomic operation
or atomicity is not that easy to achieve
so at mongodb does not support from
multi-document Atomic transactions so if
you want to maintain atomicity uh on
your database and while performing you
know while performing and saving data on
multiple documents it is not feasible
now also mongodb allows among Atomic
operations just on a single document so
in just a in one collection if it has a
single document only then you can
achieve Atomic operation
so atomicity is only maintained or
executed at the document level now like
SQL which uh you know achieves atomicity
at the table level
here in mongodb it is achieved only at
the document level and not the whole
collection annual level
all right so let us now understand how
exactly this works here now let's say I
have uh customer details collection
wherein I am having a document here as
you can see so
which the above document is basically an
embedded document here so as you can see
right uh
where we have the emitted the customer
information according to the item
purchased in the item bought by field
now the single document will help us to
check whether the item is available in
stock or not when a customer places a
new order through item available field
so if an item is available then we'll
subtract the item available field by 1
and insert a new customer name and date
of purchase details in the item bought
by field where we have the details of
early customers of the document
so in this following example you can see
we have the a particular ID let's say we
have taken as 1899 and the item name is
iPhone which comes under category of
smartphone and then we have given one
print warranty period as one city
Bengaluru country India and the store
name or the branch is koramangala so
total we have a total of 999 units in
the uh koramangala Branch here and at
present we only have 148 available items
and the list of all the uh details of
customers who have purchased iPhone from
this store has been you know embedded
into the item bought by field area list
of all customers like Rohit who
purchased uh one quantity of iPhone on
26 September similarly kirti who
purchased two items on 26 September and
so on so first just for our
understanding and I've just given the
four details now let's say if I have to
you know add someone you know who's
trying to purchase another one in such
case I have to update this document here
so how can we do that now for that we
have different commands to perform
Atomic operations
so first we have this set command set
command is used to specify a key and
update that particular field and if the
key does not exist it will only create a
null value next we have Inc Inc or
increment it can be a numeric value of
the document with a document field in
order to increase or decrease an
operation next we have push this value
is added to the field to go inside the
document it must be an array type field
only then it will accept the value that
is it can be an embedded which is
basically an array field so if the field
does not exist a new array type will be
added and next we have the pull which is
the opposite of push that is it is used
to delete a field from an array of value
which is equal into the document and
finally we have the rename which is used
to modify the field name if necessary
so let us now understand the syntax and
let's try to understand how to perform
the uh you know updation on this field
here
so in this following example we are
going to use the find and modify command
in order to perform the atomic operation
on our uh you know collection here so
this basically command helps to search
and update the document simultaneously
and it it's such a operation on a
document and it tries to achieve
atomicity that is if the find condition
matches a document the update is
performed on that document and all the
concurrent queries and additional
updates on the document are not affected
until the current update is totally
complete so the syntax is followed as DB
dot now let's say our collection name is
customer dot details find and modify and
inside the brackets the query would be
query mention the ID which is 8099 which
you have taken item available so we are
checking whether the item available we
are giving the condition as greater than
zero so if and only if the item is
greater than 0 only then we have to
update and then we are incrementing the
value that is in the item available we
are incrementing by decreasing the value
in the total await items available that
is by minus 1 and then we are pushing
the value that is we are inserting the
new record into the orders bought by uh
field wherein we have the customer
details so I am pushing uh this details
of customer name let's say Ajay and the
date of purchases first October so I
hope you've clearly understood the
syntax and how it goes so let's just go
to mongodb Shell and see how it gets
executed so as you can see mongodb shell
has started uh we'll use the show DPS
command in order to view all the
databases present in a database so we'll
be again uh using the simply called one
database so simply code one
all right let us see the collection
present inside that for that I'm using
show collections so as you can see we
have customer details which I've already
created in hindsight so we'll be using
that so let's just try to find what are
the uh details that are present in this
so because DB Dot customer details dot
find
so as you can see uh we previously
discussed the same example here and that
is also what I've created in this as
well so ID is 1899 item name iPhone
smartphone category warranty period one
city details Country Branch item total
999 items available 147 item bought by
now these are the list of customers I'm
just including only five uh I don't I
didn't have the time too you know is
that all it uh details of all the
customers it's it's time breaking
actually so just to understand for your
basic uh you know level I'm just
creating only four documents here I mean
file documents or the details of the
customer now let's say uh as discussed
in the uh you know uh presentation now
I'm trying to add another customer whose
name is Ajay and his date of purchase
for that the following query would be
DB Dot customer details dot use find and
modify make sure the MS Capital
otherwise it will throw an error and
inside that I'll write the following
query which is the keyword query
mention the ID name which is underscore
ID
which is equals to 1899
comma
item available we have the item
available field right so mention that I
item available
is make sure it is greater than use the
dollar greater than uh operator
is greater than zero only then our
updation or the transaction will be
completed and this
so close the flower brackets and now
what we are trying to update the value
right so mention the update
and we are using the increment operator
here so dollar
Inc
put semicolon
and now we know that if the item is
purchased it has to reduce its count by
one so the totem idle item available is
147 here so I am decrementing
decrementing the value by one so it
should become 146 so keep remembering
and just see that how it is reflecting
in the resultant set now so item
available
should be minus one it should decrease
by one value all right so close the
brackets mention comma and now we are
pushing the uh customer details into the
item bought by field so we have to
mention that as well so a dollar
push
mention the item bought by field wherein
will embed all the details of the
customer item
but
by
mention the semicolon and inside the
flower brackets mention the customer
details customer name is let's say a j
comma and mention the date as well
so let's say I'm taking it as first
October
October 2022
all right
and close the inverted commas and
mention all these flower brackets that
we have used
right I think this is the query I think
we are good to go now
so press enter
I think there is an error
so the errors says that you know DB Dot
customer read also is find and modify is
not a function I think uh a also should
be in caps I think we just forgot that
so let me just copy paste it again
change that
so instead of small a here for and I'll
just keep capital A I think that will be
fine so is there let's just check once
again
uh
I think we are good to go now I think
there's no more errors I think it should
be fine
well as you can see it has successfully
executed now in order to find whether it
has you know successfully updated what
you're trying to find in our you know uh
document let's just use the find command
again so I'm using DB Dot
custom mode
details Dot find
so as you can clearly see that uh see
previously we had items available 147
now it is showing item available as 146
and it has also added the customer
details which is customer name is Ajay
and the date is 1st October 2022 so what
we're trying to do here is here we first
searched for the item with the ID which
we have created which is 1899 now when
such item is found we are basically
incrementing the item available field by
-1 that is the logic brand this is if
you purchase an item it will reduce its
count by one and updating the item
bought by field which is an embedded
field which stores the data of the
customers right so by adding the
customer name and the date of purchase
of item and then we are printing the
overall purchase detail by using find
and find method right and we can observe
that the item available field has
changed from 147 to 146 and also the new
customer details have been added into
your item bought by field so in this way
you can create you know you can achieve
atomicity in a single document rather
than multi-documents that you can
perform now we also have uh two
different options of doing this which is
update 1 and update many as well
so as the name suggests update one
method modifies a single document in a
collection whereas update many modifiers
one or more documents in the collection
so let us know and let us know if you
want to create a separate video on uh
how to create that as well or
type in the comments below if you can
try that and we will see if you have the
uh you know knowledge on how to create
uh you know atomicity by creating update
1 and update many so let us see if you
can try to write the command for that so
make sure to write in the comments below
and we'll try to answer your you know
queries or uh any doubts that you have
gotten while writing the code
well I think that is pretty much uh all
about the atomic operation in mongodb
that we have discussed here which brings
us to the end of the capped Collections
and see how it is different from a
normal collections discuss its
advantages and disadvantages and then
should be using all right so what is
capped collection in mongodb now CAD
collection is a special type of
collection that has either a fixed
number of documents in a collection or
only a fixed number of elements in it it
basically creates new documents by
overriding the oldest documents in the
collection and also CAD collections have
maximum size or document counts that
prevent them from growing beyond the
maximum threshold that is been available
now all capped collection must specify a
maximum size and may also specify a
maximum document count as well mongodb
removes older documents if a collection
reaches this maximum size limit before
it reaches the maximum document count so
overall the structure and functionality
of a capped collection supports high
performance and also the high throughput
performance for applications and the
overall performances of grud operations
like create read and delete operations
as well
so let us now understand why we use
mongodb cap collection but before we
begin we have to understand how it is
different from a normal collection and
how exactly they differ from each other
so basically in comparison to normal
collection cap collections are created
in advance and are only of fixed size
whereas the normal collections are
created dynamically and it generally or
automatically grows in size to fit the
extra data that we need to incorporate
in our database so these capped
collections on the other hand are
designed to consume less space under
rotating that means once allocated space
is full it will start riding from older
documents again and that is the reason
it is called as a circular buffer
collection or simply a circle correction
which means whenever the collection size
is extra exhausted it starts deleting
the old documents automatically without
explicitly providing any commands to the
database and some operations that are
not allowed on a cap collection says
that documents cannot be removed with a
mad like you know drop Collections and
also updates that make document to grow
in size are not allowed also
so that comes to the main point on why
we use you know mongodb collections
first one is in order to ensure the
insertion order is maintained so capped
collection offer very high performance
as we discussed earlier for cut
operations because they preserve
insertion order so unlike normal
collection which keep on adding uh you
know that data into its collection uh
capped collections on the other hand
make sure that once the data is
completely filled in the collection it
will automatically delete and the
insertion operation is done on the basis
of uh you know the first come and first
sub basis
and next also we discussed Auto removal
of oldest documents
so in order to make room for the new
documents you know into a collection cap
collection basically automatically
removes the oldest documents in the
collection without writing you know
scripts or explicit remove operations in
our uh you know mongodb database and
finally install the cache data that
needs to be refreshed frequently now we
know that mongodb is a huge nosql
database and we have a lot of amounts of
data that is being generated on a daily
basis so in the same way we need to
process or you know retrieve that
information quickly right so there's a
lot of catch catchy data that is being
generated on a frequent basis so in
order to you know store all that
information capped collections can be a
useful uh tool for you so we saw some of
the main reasons why we use mongodb cap
collections all right let's next let us
discuss some uh characteristics of cap
collections in mongodb
now firstly no delete operations can be
performed now as discussed earlier uh if
you are looking to delete a document
from a cap collection then basically you
are looking into the wrong direction as
we cannot delete documents from a
capital collection the old documents in
a capped collection can only be deleted
automatically upon insertion of the new
documents when the allocated size uh to
the capped collection has been exhausted
or the maximum limit has been reached
next all the elements in collection
should have an equal size so basically
when you are creating a caps collection
you have to mention the size of that cap
collection and each element will take
the equal size of it so let's say if you
have allocated a size of let's say 100
bytes and you are trying to insert four
records in that so each element or each
document will take 25 bytes of size
so it says in equal amounts of size uh
in the collection next it works as a
queue and because of this no indexing is
required now a cabbed collection does
not contain any default indexes like in
general or
to the contrast of a normal collection
which might seem strange in addition to
this even the ID feed lacks an index for
this so mongodb doesn't waste any time
searching for a location to store a new
document on the disk let's say when
you're performing an insert operation on
a capped collection it is possible for
mongodb to add the new document to the
end of the cap collection easily so the
insert operations in collections run
very quickly because there is no wastage
in disk space organization and it is
also useful to keep log files as well so
mongodb as we discussed earlier
maintains a running log of events you
know including entries such as the
incoming connections commands uh you
know the data that are being provided
and all other stuff you know into the
database so generally log major log
messages are useful for diagnosing
issues monitoring your deployment and
tuning your performance so in order to
uh keep all these log files and to
access them in a frequent manner we use
tab collections so these are some of the
main characteristics of CAD collections
I hope you guys have understood so let
us now move understand and discuss the
syntax that is how to create a capped
collection in mongodb now the simple
syntax is DB dot uh now you can use the
syntax that you use for a create
collection right so it is similar to
that only DB dot create collection
mention the collection name as per your
size and after that mention the keyword
capped and then Boolean now Boolean here
I'll discuss uh next when you know go
through each of this next we have size
mention the number of bytes next we have
Max number all right so firstly we have
the grid collection which is a method to
create a new cap collection right next
we have a collection name it basically
represents the collection name that you
want to create we can use any name for
for our cab collection next we have the
capped keyword and then we are
specifying a Boolean value here so we
have to say at cap option which is
either true or false so if you have set
the capped option to true then our
collection will be created as a capped
collection so in on the other hand if
you have specified The Collection option
as false then the collection is created
without any cap collection and finally
we have the size size option will
specify the limit of size for the cap
size cab collection sorry so we can
specify the size of our collection in
bytes in general for capped collections
so this parameter is actually mandatory
when we have defined a collection which
is of a cab collection type
and finally we have Max where you have
to provide a number that is how many
documents that you want to incorporate
in your cap Collections and when you
want to specify uh or you know limit the
maximum number of documents that are
allowed in your collection size option
will give preference over the max option
in mongodb in general
so that was uh the basic syntax on how
to create a cab collection and if you
want to know whether your collection has
been capped or not you can use this
following command which can be visible
on your screen which is DB dot let's say
my uh
you know collection name is capital log
collection and if you want to see
whether it is created or not I am using
ease capped keyword so this is how you
can use these commands in order to
create and view your collection which is
of capped type in your mongodb database
so I hope you understood how to create
uh this I mean the syntax on how to
create a cap collection so let us now
directly jump into mongodb shell for
execution part
so as you can see mongodb shell has
started and firstly let us look at our
databases which will be our first
command which is show DBS so again we'll
be using the same simply code one
database
in order to understand how cap
collection works so let's let us see the
collections that are present
so simply code one has various
collections like collection collection
name customer details employee marks and
new employees so let us now firstly uh
create a capped collection so as we
already discussed the syntax of uh the
capped collections so let's just execute
it now
so the uh
syntax is followed as create mention
create collection keyword
and inside that mention the cab
collection name so let's just take a
log collection one so you can keep it a
name of your own choice so
it's up to Yahweh
lose the uh
brackets and
open the flower brackets and mention the
capped keyword and I'm specifying it as
true that is we want to create a new
capped collection all right
and select as true and comma
mention this size so let's just keep
let's say thousand bytes for our cab
collection so this is how you basically
create a capped collection in your
mongodb database click on enter
so it will say OK one that means you
have successfully created now we have
only create uh just specified this size
to our CAD collection so if you want to
limit the number of documents that you
want to you know insert into your cap
collection then you have to mention the
maximum size also so for that what
you'll do is we'll provide the
additional you know Max uh constraint as
well so after size mention the max
keyword
and just for understanding I'm just
keeping it uh you know where for a
simple number I'm just keeping three all
right so since I'm keeping 10 3 is the
number of documents that the collection
will collection will overall have so
let's say if you're trying to insert
another documents after you know
inserting first three documents then it
will automatically replace with the new
one so let's just see how it will work
but I think we have to change the
collection name again here so I'm just
taking it as log collection too
and okay Okay click on enter all right
again it says ok one that means you have
successfully created or not created but
again let's just find out whether uh you
know collection is capped or not for
that we have already discussed we have
to use the East cab you know method for
that so DB dot mention the collection
name which is a log collection to
dot is make sure the capped uh C is
capital
so it is true so that means we have
successfully uh you know created a
capped collection and it is not just a
normal collection so let us now try to
insert some records or data into our you
know this capped collection and see how
it works so DB Dot
uh mention the collection name which is
log collection
two dot again you can use the insert
command which is a regular one right
so mention the OpenFlow brackets and
let's say let's just take let's just
insert uh you know a normal a basic type
of info let's take a name I'm just
taking it as let's say a Rohan
all right let's close the brackets
all right it is
okay now you might find this warning it
says collection dot insert is deprecated
you use insert one insert menu or bulk
right as in your command but it's just
fine you know you can also use just
insert it will work as you can see it
has successfully created acknowledge
true and it has inserted ID so similarly
we will insert another two documents
and see how it actually represents in
you know in our real time so let's just
take uh
another name let's say uh pretty
all right and let us take another
uh by above
sticking a random name so I think
so we have cleared successfully inserted
three and since we have put a limit of
Maximum three I am just inserting three
and what will happen if you're trying to
insert the fourth record we'll see how
it works so let's just uh display the
requests that are present in a
collection for that I am again using our
collection name and I'm using the file
method here so as you can see it is
successfully retrieving all the three
documents that is uh the details of
Rohan Priti and bivof now what if I am
trying to insert a new document here all
right I'm just copying this and let's
say I'm trying to insert a fourth
document in this uh I'm trying to insert
a new document whose name is let's say
kirim so
in such case and if I am trying to find
uh the data again that is present in our
you know law collection to which is a
cap collection so you can see that
we had previously had Rohan Preeti Baba
now we have Preeti bhaiav and Kiran that
means the older one which is uh Rohan
has been successfully deleted from our
you know uh collection here so we know
that due to the circular and the fixed
side nature of the capped collection
there are restrictions to this update
operations so whenever you are trying to
add a new data and if updating of any
document in the collection results in
the increase of the document size so
previously we had three and now we are
increasing it to four that is the size
is increasing then mongodb will not
update this document in that collection
because documents in the cab collections
are stored in the order of disk disk
storage which ensures the size of a
single document does not exceeds its
allocated size on the disk so that is
the reason why uh it is basically based
on the first come first serve basis and
it will automatically delete the old
documents whenever you're trying so
trying to insert a new document into our
collection
so this is how in general you know CAD
collection works I hope you understood
that now let's say if you want to
convert you know already present
collection which is a non-cap collection
if you want to change it to a cad
collection in such case you can use
another query for that right so
basically the query would be
DB Dot
run command
open the flower brackets and mention the
keyword which is convert Capital to T
o and capital capped Capital C in cap
keyword all right so let's just enter it
now let us take one collection here
let's say I'm trying to change this
employee which is a non-capped
collection into a cab collection so I'm
just specifying employee here
okay I forgot to mention
videos
inverted commas so mention in the
inverted commas and again provide the
size let's take a size as 10 000 bytes I
mean it's a your preference you can give
it as per your need and maximum I want
to store only 100 documents in this uh
you know cab collection
so as you can see it is successfully
saying okay one that means you have
successfully converted a non-capped
collection which is employee collection
into a capped collection
well I think uh we have covered pretty
much all about you know what is a cat
collection how to create it its syntax
and how it exactly works it is
authentication in mongodb and we'll show
you how to enable authentication so that
only authorized users can access the
database and its content present in
various Collections and documents in
mongodb database so what is
authentication in mongodb now
authentication and authorization are two
important concepts of any database
authenticating users with your database
is a critical security feature as well
as the authorization now these two terms
might be uh similar but they have a
different meaning to each other now when
it comes to authentication identifying
all the users who connect to the
database is called as authentication on
the other hand authorization is
basically restricting actions on
authenticated users that can perform any
operations in your database which is
known as authorization now similarly in
a no SQL database like mongodb we do
provide authentication for users in
order to curve some unrestricted
activity from others while performing
you know mongodb operations so this is
especially true when the database
contains sensitive data such as users
accounts for a website or company's data
so basically when you enable
authentication on your mongodb instance
you can specify what user accounts are
allowed to do and what level of access
they have and what level of uh you know
activity they cannot have so this also
means that you can restrict access to
certain features to only authorized
users working with no authentication can
be okay for you know developing a
a development or testing environment
initially but when you're in production
with customers and the data stored
inside is mandatory or which is of key
importance it is important to restrict
access to the database so that only a
specific amount of users who have the
authenticity or authentication to the
database has the access to uh you know
cover all the operations within the
mongodb database
so that is what exactly is
authentication in mongodb it is
basically the process of confirming a
client's identity that is it requires
all clients to authenticate themselves
when access control that is whenever the
authorization is enabled to them
now authentication is done in three
different ways in three different stages
now firstly we have to create the users
so users who have access control enable
must identify themselves and are only
permitted to take actions that fall
under the permissions granted by the
role assigned to them now before
creating a user you need to have you
need to enable Access Control enabling
access control on a mongodb basically
deploys the authentication process and
finally after giving Access Control you
need to authenticate the user finally
you need to provide the username
password and the authentication database
linked to that user which is required
not to authenticate as per that user
now there are various commands you know
that you can use to authenticate mongodb
database so for creating modifying and
delete deleting users within mongodb and
configuration and con to configure
authentication the core methods you need
are DB dot create user this basically
creates a user for authentication
purpose
next we have the DB dot update user and
DB dot drop user these two basically
updates the details of a user account as
well as deletes a mongodb user account
and finally we have DB dot change user
password it basically changes the user
uh passwords your password used by the
user account
so let us now understand how to create
authentication in mongodb for that we
have already learned that we need to
create a user and the syntax is uh
followed as DB dot create user within
the parenthesis mention the user keyword
wherein I'm just taking admin and I'm
giving the password as one two three ABC
now we have another
criteria where we have uh we need to
mention the roles here and within the
parenthesis I mentioned the role as user
admin and the database that we are
providing is admin database here
now once you are done with this it will
basically say that it's okay one that
means you have successfully
authenticated but you need another step
in order to verify whether it is created
or not you need to use the auth that is
DB dot auth is a keyword wherein your uh
verifying whether the authentication is
done on the database that you have done
or not so I'm just checking using this
syntax which goes as DB dot auth uh
mentioned in the database which is admin
sorry the user username that you've
given is admin and the password we have
given is one two three ABC so this is
how you can create authentication in
mongodb by using the create user method
I hope you understood this so let us now
jump into the execution part and see how
exactly it is done so as you can see
mongodb Compass has started now firstly
model Lewis will create a database and
inside that will create a collection and
basically then we'll do authentication
on this collection wherein we'll do some
read and write uh you know restrictions
you know for the New Year's new user who
is trying to insert new documents into
that collection so let's just create a
database first let's take let's say I'm
creating a student database so I'm
giving a student DB and let's take a
collection name as student details all
right so let's just create it
student DB has successfully created
database now you can go into this
collection and let's just add some data
for our reference and uh let's see I'm
just going to insert some simple uh
document into others so we'll add
basically a field I'm just giving name
and the name would be
let's say Rohan and I'm adding another
field
let's say h is 25 all right so let's
just insert this now we are successfully
inserted a document into a collection
student and details now we are done with
this now let's just go to mongodb Shell
and get in with the commands now so you
can directly open the mongodb shell or
even you can use CMD wherein you can
open command prompt and you can give the
command as Mongoose which is basically
your connection to mongodb Shell which
is a shortcut
so just wait for it and it will
successfully open so let us now see what
are the databases that are present in
our database so we have various
different databases like admin company
DB config local simply code one student
DB test
right so now you can create
authentication on any database as per
your business you can even create a you
know authentication on admin database
company and DB database so for a bit of
better understanding we have considered
here student debut database so we'll
basically use that use
student TV so switch to DB now
let's say show Collections and we will
see we have the student details so let
us now find the details for that student
dot DB dot student details dot find
so we have inserted one document uh
which is of name Rohan and age 25 so
this is basically a normal uh way of
creating a document in a database right
so let's just create another uh just
insert another document into this okay
for our reference I'm just taking a
reference and we'll see how when you're
trying to add or when you're trying to
read or write some operations after
authentication how it will impact so
and just create inserting another one to
run it a lot insert and within the
flower brackets mention the
single quotes name let's say name as uh
oven
mentioned in single quotes
close the brackets and let us take age
as
26
close the flower brackets and enter
so it will say it is successfully
executed now let's just try to find this
again
so we have inserted two documents here
now this is done now we have to create
basically a a user for creating the
authentication for our database now
we'll see how to create that now since
we already discussed I'm just copy
pasting it here guys
so as you can see I am creating a user
which is of username Rahul and I am
giving password as per your choices
let's say one two three APC and then I'm
providing the roles which is role as
user admin let's say and the DBS student
DB all right so press enter
so there was a bit of error in the code
guys now basically there are some
certain you know keywords for role here
so for admin access you have to provide
only as admin not as user admin and I am
here taking the role I just read so that
whenever you are trying to perform a
read operation on that it will provide
an authentication for that for our
database so you can see it was
successfully created and it shows OK and
one now we are done with this part now
basically we just created a user now we
have to enable the authentication so for
that you have to find the
mongodb.cfd file so now where you'll
find that is basically in your uh you
know where you have installed your
mongodb so I'll just navigate to that
path first so open uh the C folder where
are the location where you have said I
have saved this in C drive so go to
program files go to mongodb folder click
on server click on 6.0 go to bin
and you can see mongod.cfg so this is
the file we want click right click and
let's say open with Notepad
so once you open this you'll find a log
like a description of all the
configuration that it has when you
scroll down a bit you will find that
hashtag security so remove this call a
comment and just write
as Authentication
okay what this does is basically you're
giving control access to your database
so so that of any other user is trying
to you know read your operations from
your database he can uh use this so
let's just save this
key program file or you don't have
permission to save this location contact
the administrator to obtain permission
click on yes
so we have successfully given the
authentication where we have provided
the command liners or the authentication
enabled now once you are done with this
you have to restart your system so for
that you have to basically stop the
services of Bongo DB now for that what
you'll do is basically just go to your
home page try to find for mongodb
scroll down a bit and I think you'll
find here uh yeah so mongodb server it's
running click right click on that
so we have successfully uh restarted the
mongodb server so let's just go to a
mongodb shell again
open CMD and type Congress
and right now let's say show DBS and let
us use the student DB
collections
all right now we have student details in
our uh collections of student DB
database now since we have authenticated
it let's just verify whether it is
created or not so for that I'm using DB
dot auth which you have discussed
earlier open the square brackets
So within the inverter codes mention the
username that we have provided as
student DB only for our database and
mention the
password so we have kept as one two
three ABC all right so just close it and
press enter so it says ok one that means
you have successfully created uh the
authentication on your database now
whenever you are trying to retrieve data
uh it will make sure that you know only
a limited number of people having this
username and this password has this uh
you know in order to open this
collection so let's just try to find
whether it is showing or not so for that
I'm using the student details dot find
command
and you can see the details are being
displayed for our uh the user who's
trying to uh retrieve the data that is
present in our student return details
database after uh you know accessing the
after getting the authentication from
the database so this is how you can
create authentication uh on a user
database you can even create an admin
database or even you can create on test
database and with that we have come to
the end of today's session guys I hope
you've covered everything pretty much
about you know authentication in mongodb
so authentication is like one of the
most critical point of uh you know any
database in terms of security it will
basically allow us to wired it and
verify the information of the user who
is connected with the current instance
of mongodb and if any user has no uh
privilege or association with the
database collection then his request
will be automatically well denied and
this is where authentic authentication
plays an important role without having a
user relationship with the database we
cannot authenticate the user user and
role Management in mongodb and
understand various commands that are
used to perform these two technicalities
so firstly let us discuss what are user
management commands now user management
commands are basically used to manage
the user access to the database mongodb
offers an internal method called
db.create user method that allows user
to be added to this system now unlike
conventional databases like uh SQL or
relational databases mongodb users are
connected to local database known as
authentication database and additionally
unique identifiers include the
authentication database and the user's
name assigned to it and consequently if
two users are created in different
database but have the same names they
are recognized as two separate users
therefore rather than creating the user
multiple times in various database one
should allow a single user to have the
rights or roles to the relevant database
instead of creating the user multiple
times in different databases so let's
say if one wants to create a single user
with permissions on multiple database we
can give the access to that particular
person so that is basically what is user
management is all about in mongodb now
that is done using various commands in
mongodb database now first we have the
most important one which is create user
this method basically is used to create
a new user in your mongodb instance next
we have the drop all users from database
it is used to delete all the users from
a database or the collection of data
that you have in your documents right
and next we have the drop user command
which is used to Grant a task and its
privileges to a user next we have Grant
roles to user it is basically assigning
a role and its Associated privileges
that can be given to a user on a basis
on a regular basis and finally next we
have revoke roles from user which is
used to remove the access to the user
role that you have given earlier next we
have the update user this method
basically is used to update a user's
data and finally we have users info so
let's say if you want to return the
information of the users that you have
created you can use the user info so
these are some of the major user
management commands that we use in
database now you will understand it more
clearly when we get into the execution
part so for now let's just understand
what this is okay let's move ahead and
understand what role management commands
now our roles Grant users access to
mongodb Resources by providing several
built-in roles that enable the
administrators or the users to control
the access to a mongodb system although
these roles cannot describe the desired
set of privileges one can create new
roles in a particular database time to
time so except for functions created in
the admin database a rule can only
include rights that applies to its
database and those inherited from other
roles and only the user who has granted
this access has this you know permission
you know in order to control and access
the data from that mongodb database so
similar to user management we have
various different commands here as well
the first one is create role it is
basically used to create a role for the
user database and say what you can
perform to that database next we have
drop role it basically removes the role
that was set by the user so which is the
again the opposite of creator so if you
want to create drop a row that you have
assigned to the user you can use the
drop role command next we have drop all
rows from database now let's say if you
have created a user and given let's say
five to six roles to that particular
user now for due to some external
factors or reasons if you want to delete
all those roles at a time you can use
drop all rows from database command
which basically removes all the rows
that the users from the database has set
up next we have the grant privileges to
rule it is used to assign privileges to
a role that the user chooses and finally
we have the update rule which basically
updates the role that was set up by the
user now again these are some of the
major uh commands that we use in as uh
mongodb if you want to learn more about
these you can go to mongodb your website
and clearly understand what are the
different commands that we are using and
we will basically execute them in
mongodb shell and only then you'll
understand how important and how they
exactly get executed so so let's
dive directly into mongodb shell but
before that we will just see a simple
example where we'll understand how user
and role management command works now
I'm using a simple database which is
employees and then I'm creating a user
which is the syntax is followed as DB
dot create user and then I'm giving
username as rohan123 and I'm giving the
password one two three ABC and next I'm
also giving the roles to this user that
is I'm giving the read operation that is
uh the user who have the access to this
database employs can only read the
information that is he can just view the
data but he cannot make any changes to
this DB employs table so I hope you
understood uh this so let us now
directly jump into the execution part so
as you can see mongodb shell has started
and the basic command is basically to
show the different database in our
different databases present in our uh
you know mongodb instance so for that
I'm using the show DBS command
which will bring all the virtually all
the databases like admin company DB
config local simply code one student DB
and test
so we know that before we enable Access
Control you should create a user that
can create users and assign roles to
them once access control is enabled so
this user admin will then use to create
and maintain other users and role which
needs to be assigned a suitable role to
enable it to do so so you can have
various low roles like admin role you
can give the read operation you can give
right operation either and you can
simultaneously give read and write
operations on on the data that you want
to perform uh the analysis or the
changes you want to make
so before creating a mongodb user
actually it is worth thinking about the
task the user is going to perform now
let's say I have a database here let's
say simply code one and I have a user
who is who constantly uh changes or
updates data from the database then I
can give the role to the to that
particular user is rewrite operation so
by Chain probably there will be several
users with the same level of permissions
also so the smartest option is to create
a role and assign it to each of these
users and by only changing a role you
will update the permission where all the
users who has the access to it otherwise
a change to an access requirement for a
group or you know a group of users would
need to be done for every single user
every time so the first step is to
change context to database in which
you're going to create this role so
let's just create a simple
uh you know roll to a database
so for that I am using the simply code
database only here so let's say excuse
simply code one
so it is switched to Simply code one
so when adding a new user to the
specified database and for in our case
it's simply code one we use the
db.create user method which is the
fundamental command so it is important
to note that adding users with option is
much simpler than inserting a user
document into a non-relational database
so the query is followed as DP Dot
create
User make sure the US capital otherwise
it will throw an error open the brackets
and inside that mention the keyword user
so let's say I'm giving the user name as
let's take a Rowan one two three four
close the brackets and then mention the
password PWD
so you can either give a password or you
can give a password prompt password
prompt is basically will ask you to
enter the password every time you
request access to this database so I'm
just using the password prompt command
here
and then you have to specify the roles
that you want to create your uh you know
database so let's say I'm just giving a
simple role as let's take as read
operation right so for that I am
providing roles
and
within the uh square brackets
mention the rule
keyword
semicolon and since we are concerned
with read I am giving it as a read
and then mention the database that you
are giving the access to so the the
database is simply code one all right
make sure it is an inverted commas again
otherwise it will draw an error
so I think the code is done let's just
execute this again grow with the square
brackets make sure to check all the
brackets are being properly closed
otherwise it will throw an error
we have a square bracket
and then I think
oops again another on this okay
so it says enter password now you can
give password of your choice so let's
take one two three quantity dot okay
so it's easy to successfully executed
let's just walk through what you have
created here now to create a user who
will manage a single database here which
is the simplicode one we can we are
using the same command which is the
db.create user and in that uh we are
giving a particular user name and then
we are giving the rules to it so the
first step is basically to specify the
username and password which needs to be
created and the second step is to assign
a role for the user which in this case
needs to be a is a general user not the
user admin right so we are just
assigning a role which is the read
operation here this role basically
allows the user to have privileges only
to the database specified in the DB
option which is simply code one so the
DB parameter specified that database to
which the user should have the
administrative privileges on so the
output basically shows that it was
successfully created and it is asking
for a password now you can generally
give a password of your own choice or
you can either just give a password
prompt and then you can enter the
password
so this is how you create a user now
next you have to manage these users so
for that you have to understand the
rules which you need to Define now
there's a whole list of roles available
in mongodb as discussed earlier now for
this one we have given read now there is
also read write there is also user admin
which we give for administrative uh you
know privileges or uh someone who have
the who needs to be a database
administrator who constantly works on
that database so for that we provide
with that so then we have this again
read role which basically allows you to
read only access to databases and then
there is read write also which provides
read and write access to the database
which means that the user can insert
delete update commands on collections in
that database so let's just create
another uh user where it will create
multiple roles and understand how it
works here
so again I'm just copy pasting this and
will create another user and see so
let's just change some of the names here
let's take the new user as
user one
and let's take the password prompt same
and then we will assign different roles
now for different databases for this
user okay
now once we have created a read
operation for simply code right now
let's take another database let's say
company DB so for that I am creating
another role
which is read write okay
so there is a small error so I'm just
copy pasting the file which I've already
created to show you so I'm just creating
a new user and then I'm
creating a user named rohan123 and let's
take the password as one two three ABC
and the rows that I'm giving to this
user are from various database so for
let's say for simply code one I'm giving
the role as read operation and for
company DB I'm giving you the operation
and for student DB I'm giving the read
write operation so mongodb defines roles
uniquely by combining the database with
the role name and each role is scope to
the database you have created but
mongodb generally stores all the role
information and this collection in the
admin database so for instance the role
and Grant role actions on the database
resource must ensure that sir roles are
created and granted in the database so
let's just execute this and see the
output so it says ok one that means you
have successfully created a user now you
want to see all the users that you have
created in the simply code one you can
simply use the show users command which
will list out all the users that you
have created so it says simply got one
dot Rover one two three DB simply code
one and the read roles that you have
created is read operations for this
database for read operation for company
DB read operation for simply code and so
on
and you can also show the roles as well
separately so it will just show all the
different roles so let's say role DB
owner DB simply code one
and like in a similar way all their
operations all the roles that you have
given uh will be showcased here I think
we have pretty much covered the basics
of user and uh role management commands
in this what are mongodb session
commands now session commands basically
allow you to provide specific
instructions to the database through a
command language using certain uh
commands so we'll be learning uh exactly
what are the mongodb sessions and
various types of commands that are used
in this criteria so firstly what are
session commands in mongodb now a
session is basically is used to group
together a series of operations that are
related to each other which would be
executed with the same session options
now if you consider mongodb mongodb
shell does not uh is not typically used
to write and execute transaction the
majority majority of the time external
applications use transaction instead so
the application must initiate a session
in order for any transaction action it
performs to be guaranteed with the asset
properties like atomicity consistency
isolation and durability
so a session is a database object in
mongodb that is controlled by an
application using a proper mongodb
driver which can be used with various
applications like CEC plus plus python
Java and other applications as well so
this basically enables the driver to
apply additional configurations such as
enabling the use of transaction whether
you want to start a transaction or you
know terminate a transaction to even a
group of database statement as a whole
so as a result they will have a shared
context and can be associated with each
other using the session commands where
it will process sequence of database
statements
so that is what exactly the session
commands are in mongodb
so this can be performed using various
mongodb session comments so we have
typically five session commands in
mongodb namely
firstly we have the about transaction
command which is basically is used to
stop or terminate the ongoing
transaction next we have the commit
transaction command which is used to
permanently save all the transactions
done in the mongodb database next we
have the end sessions command which
expires is to expire any ongoing
sessions before the timeout so in
general mongodb has a timeout period of
30 minutes so after that it will
automatically in the session within a
mongodb instance so if you want it to
done before uh the computer
automatically does to you you can use
the in session command next we have the
kill all sessions images used to
terminate all these sessions right as
the name says kill all next we have the
kill all sessions by pattern now you can
even uh terminate a session or stop a
particular session by using a specified
pattern so if ever if the pattern
matches a specified uh you know
character that you mention in your
server session in in that case you can
use skill all sessions by partner now
we'll be understanding each of them uh
in a more depth with its syntax and how
it works
now apart from this we have the basic
and the generic type of session commands
in mongodb where we have refresh
sessions kill sessions and start session
all
so the refresh session command is used
to update the end use time for the
specified session by extending the
active state of the session so if you're
working on a particular uh transaction
and if you want to uh you know refresh
it in that case you can use the refresh
session command which will basically
extend the period of this session that
your the ongoing session is happening
next we have the kill session so if you
want to uh you know exit or terminate
only a particular uh specified you know
uh session for the user in such case you
can use the kill sessions next finally
we have the start session command as the
name suggests the start session command
is used to start a new logical session
in the mongodb database now the
constraint here is you must be
authenticated to run this command that
is proper authentication should be given
to the mongodb database otherwise it
does not enforce
so if the deployment does not have any
uh authentication or authorization a
created uh has no owner and can be used
by any user over any connection
so these were some of the types of
session commas that we use so let's just
get into detail with each of the command
here so the first one is what is about
transaction command
so the about transaction uh command or
the method tells mongodb to undo all the
modifications made throughout the
transaction and restore the database to
its initial configuration
so it basically terminates all the
multi-document transaction and rolls
back any changes made by the operations
within the transaction that is the
transaction basically ends without
saving any of the changes made by the
operations in the transaction now the
award transaction command must be run
within a session and run against the
admin database only and another
constraint is it will terminate any
transaction before it can get executed
because one of the operation caused an
error so to run the above transaction
the command must be uh run against the
admin database and run with the start
session initially
so let us understand the Syntax for this
the syntax is followed as DB dot admin
command and within the brackets mention
about transaction and we are given a
Boolean value that is 1 that means true
next we have the transaction number it
can be of any type so I'm just
specifying the long next we have the
right concern mention the document name
and then I'm giving Auto commit to false
next we have any comments if you want to
uh display in for the reason why you are
aborting the transaction you can specify
it here so when a transaction Awards all
the data changes all the data changes
made by the right transactions are
discarded without ever being visible to
the visible and the transaction
eventually ends automatically
next we have the what is commit
transaction command now commit
transaction ends the transaction by
saving the changes made by the
operations in the multi-level document
transaction so you can say this is
basically an opposite of about
transaction command which will basically
ensure that it saves the changes made by
the operations in the multi-document
transaction and nset transaction as well
so again you are to run the commit
transaction you must run it against the
admin database using the DB dot admin
command so the transaction is same again
which is similar to that of the about
transaction instead of about transaction
mention the commit transaction keyword
here and specify it as one and the rest
all the fields where you have the
transaction number write concern uh Auto
commit comment will all have the same uh
you know criteria so the right concern
basically tells you that when committing
any transaction the session uses the
right concern on specified in the
transaction start
so let's say when a transaction commands
and all the data changes made in the
transaction are saved and visible
outside the transaction which which
means a transaction will not commit some
of its changes while rolling back the
other changes so until and unless a
transaction commits the data changes
made in the transaction are not visible
to any user outside of the transaction
so I hope you were clear with the
comment transaction next we have the
what is end sessions command
so basically n session expires the
sessions that are specified now the
command overwrites the timeout window
that the sessions wait before closing
now what do I mean by that
so this method basically closes an
existing session so if a transaction was
Associated within this a session the
transaction will get uh aborted once you
uh you know give this n session command
so after calling this method application
should not invoke any other commands on
this session anymore so let us
understand the syntax the syntax is
followed as DB dot run command and
within the parenthesis I am giving the
end sessions keyword and inside that I
am mentioning ID where you have to give
the uuid now guid is basically and you
know alt uh alter uh you know
specification for you know object ID we
have in mongodb so mongodb and other
mongodb drivers come with this inbuilt
support for the uuid data type and it's
very easy and convenient to start using
the uuid immediately as well
so it basically mongodb itself stores uu
IDs as a binary field and when such
binary fields are accessed from software
mongodb drivers usually convert their
value which is found uh in the database
to language specific uh you know uuid
objects so that is just an opposite of
I'm not an opposite I can say it is an
alternative uh to the use of object ID
in mongodb
so that is what in session is all about
next we have the what is kill all
session command now killing a session
terminates any in progress operations in
the section session so we haven't
discussed what exactly why we are using
kill uh keyword here so the mongodb
takes this command in order to terminate
any ongoing process or the operations in
that session
so the kill all session commands kill
all the uh you know sessions that are
being run on the mongodb database and if
access control is enabled the command
only kills the SEC sessions that are
owned by the user so let us now
understand the syntax now
we have uh you know kill sessions as
well uh as in addition to kill all
sessions so the basic or the generic
type of syntax that we write here is DB
dot run command inside that we are
specifying kill all sessions and you can
either give a particular user and the
database name wherein the command takes
an array of documents that specify the
uuid portion of the session ID or else
what you can do is you can just simply
run the DB dot run command where you are
just specifying kill all sessions which
will automatically terminate all the
operations in the in that particular
session and if you want a particular
only uh specific type of uh session in
that case you have to mention the user
and the DB Associated to it so let's say
I have uh this uh two users right I just
want to uh
stop only these two sessions right in
that case I'm using DB dot run command
kill all sessions and I'm just giving
the username and the DP so Rohan one is
the user and the DB that is working on
is employee one so it will basically
terminate all the sessions or the
transactions that are ongoing that is if
you're performing any read or write
operations on this it will terminate all
the sessions in one code
next we have what is kill all by session
all sessions by pattern now as the name
suggests we are basically stopping all a
particular session with the help of a
specified pattern here which is the
definition of this command is to kill
all session by pattern command kills all
sessions that match any of the specified
pattern now the syntax is also similar
to that of kill all sessions which is DB
dot run command and inside the
parenthesis we are giving the keyword
kill all sessions by pattern and mention
the pattern here now there are various
patterns that are associated uh with
this so you can either have any of the
four choices that you can see in a table
here now the first one basically
specifies the uuid portion of the
session ID that you want to terminate
next you can just give the uid or and
give the bin data which will basically
specifies the hash of the owner of the
session to kill next you can just give
the uh you can just specify the owner of
the session you know to kill or to
terminate save that session which will
require additional privileges
and finally you can also terminate a
session by just giving the role to that
database so if you specify the role
assigned to the owner of that session in
order to stop it you can just give to
that a particular role as well which
will again require additional privileges
now what I mean by additional privileges
here is that so if the database that
you're working on enforces any
authentication or authorization you must
have the kill any session or kill all
session privilege action in order to run
the kill all session by pattern command
so only in such case you can use this
type of command which is skill all
section by command if you have the
permission of kill all session command
so that is what uh kill all session my
pattern command is all about
and with that we have come to the end of
today's session guys I think we have
discussed pretty much about all the uh
session commands that we use now in
terms of
working on mongodb database it is not a
um important topic to uh you know learn
it is just an uh conceptual topic maybe
you might be asked in your interview
questions but in general if you're
working on a database you might not use
uh more of the session commands so it is
important to uh have a knowledge a
pretty much knowledge on what are these
session commands and what is the basic
significance on why we use in our
mongodb database what is backup and
restore in mongodb and how to implement
in real life so we will walk you through
the steps of backing up and restoring
process in mongodb database and also the
collection present in them so firstly
let us discuss what is backup in general
before we understand how backup Works in
mongodb now backup and Recovery refers
the process of creating and storing data
copies that can be used to protect any
organization or companies when they have
any data loss so this is referred also
to as operational loss and recovering
from a data from a backup usually
Intel's restoring the data to its
original location or that is copying of
data in other location where it can be
used in place of the lost or damaged
data now to predict D against data loss
due to primary Hardware or any software
failures a proper backup copy stored in
a separate system or a medium like hard
disk or pen drive from the primary data
now data should be backed up at regular
intervals because it is important that
you have the access to the data Within
the data should be backed up in no time
so that you can access the data in
whatever uh you know situation you want
and it also determined by how frequently
the data changes and depending upon that
you have to backup your data it might be
every week every month or maybe once in
a quarter or like that
so moving ahead just like uh the backup
which we do for other systems as well
mongodb also requires backup since it is
a nosql database and it works a lot on
non-structured data which has large data
sets and in order to ensure that the
customer uh the user's information is
stored properly and their identity and
their data is safeguarded it is
important that we you know back up the
data into our mongodb database so for
that mongodb provides with various
inbuilt tools for example thump as
well as mongolistore commands which is
used to connect the mongodb instance on
a local system and create a database
backup named dump in the current
directory now we'll understand how it
works when we get into the execution
part so for now just just understand
how does mongodb backup works now now
there are various ways in which you can
backup your data in mongodb so if you're
working on mongodb Atlas you can use
so mongodb Atlas which is the hosted
mongodb service option in the cloud
offers basically two types of methods
for backups which is cloud backup as
well as Legacy backup next we have the
mongodb cloud manager and ops manager
now mongodb Cloud manager is a hosted
backup monitoring and automation service
for mongodb the mongodb cloud manager
supports the backing up and restoring of
mongodb deployments so mongodb Cloud
manager generally backups mongodb
replica sets and sharded clusters by
reading the op log data from your
mongodb deployment and next we have the
basic tools like dump which is an
easier way let's say if you are trying
to backup data which is less than a 100
GB of 500 GB in such case Monger dump
which is a inbuilt command tool is a
great option for you and finally we also
have file system backups where you can
create a backup of a mongodb deployment
by making a copy of mongodb's underlying
data files so the volume where mongodb
sources data file supports point in time
you can use this uh file system backup
you have to create backup of a mongodb
system at an exact moment in that time
so in this tutorial we are only
concerned with the mongodum and we'll
see how it works
so to create backup of a database or a
collection you should use mongodum
command let's see how the syntax is now
the syntax is simple you just have to
write mongodum and again let's
understand this when we get into the
execution part so if you want to uh
backup only a particular database or
let's say a particular collection in
such case the syntax would be dump
mention DB and the database name next
mention collection keyword and the
collection name and after that mention
out and the location path of it so in
this way you can use this command in
order to backup a particular database
and a collection name so mongodum is an
ideal backup solution for let's say
small mongodb instances due to its ease
of use and portability
I hope you understood you know what is
backup and uh how does it work in
mongodb so let us now jump into
execution part and see how it is done
we'll also see how to uh once we backup
our database and after deleting or
dropping the database of the collection
how to restore it back to its original
uh position in the database as well
so what you have to do is you have to
basically first open command prompt and
before we get ahead with the execution
pattern how to backup our mongodb
database you have to install the mongod
dump which is a command line which is an
inbuilt command line so what you have to
do is you have to uh go and download
the data which is the command lines from
the mongodb official server so for that
what you have to do is type mongodb
command lines database tools all right
so scroll down a bit and you'll have
this download mongodb command line
database tools click on that
and you can see that we have this
mongodb command line database tools
download and all the description of this
I will file the latest version of it and
you will have the package ZIP here just
uh
remove that and select MSI package and
click on download now I've already
downloaded it on my system so I'll just
show you what has to be done
so when you download it it will ask for
uh
this setup just give the permission
necessary permissions and all
so as I've already installed it says you
can change the features I have installed
repair now just click the next button
until you finish it okay
now once you are done with that it will
basically uh store the data in the C
drive so go to program files in C drive
and open mongodb folder and in that it
will be downloaded in tools section so
click on this tools you'll have this 100
click on pin so this is where we have
the all database tools for example based
on dump dump expert
files import restore
mongostat and top so this is how
you have to download the basic command
line tool which is which since you are
working with mongodum which is a part of
a command line tool we are downloading
this so all right so once you're done
with this now go back to our Command
Prompt and next type mongoose
which is basically directed to our
shell all right so let's just get
started I'm using the show DBS command
here so it says various uh shows the
various databases present in our uh
mongodb database right all right now now
you can now you can work on the existing
database or you can create a new
database in order to back up the data
that is present in that so let's say I'm
just using a new database here let's say
the database name is mongodb backup
okay so it says switch to DB
backup so let us now just create a set
of collections okay for example we'll
create two collections so the first
collection would be orders right so I'm
just creating collections DB dot orders
insert and inside that I'm basically uh
just creating a field let's say let's
take a name let's say Rohan
okay
so this is this is just for example guys
I'm just showing a basic example so that
you'll have a clear idea on how the
backup works here so similarly let's
just create another collection let's say
customers
Dot
insert
and let's say take the name as Rahul
right close the brackets
well as you can see in the assertion
tool we can see that it is successfully
acknowledged true and it is inserted IDs
are also created so let us just uh use
the show collections command whether or
not we have created or not so you can
see customers and orders are the two
collections that are created inside the
mongodb backup
now once we're done with this we have to
create a path or let's say a folder
wherein we are trying to backup the data
that is present in our mongodb database
so for that what you have to do is go to
let's say C drive and just create a
folder let's say I am creating a new
folder here
let's take the name of the folder as
backup Okay click on that
now click on there open the backup
folder now you will see that folder is
empty now now since we haven't done any
backup on our database it will show this
folder as empty now what you have to do
is just copy this uh address okay just
double click over here and just copy the
address now
now once again open command prompt
all right
now we have to set the path to our
location which is the see the where you
have created the backup folder so for
that I'm using the CD which means
current directory and just copy paste
the location that we have just copied
okay which is the C backup file now
click ok now it is change to C backup
now we have to set up the path for our
backup file right now for that I'm using
the set path
so we have to set path for our mongodom
Command which is uh basically stored in
I think
the program files again just go there
click on program files click on mongodb
click on tools click on this open bin
and just copy paste this address over
here
copy
just open this and within the brackets I
inverted comma sorry I'll paste this
click ok now that means you have
successfully uh set up the path for your
mongodum command wherein the data that
you have created in your mongodb
database that is the mongodb database
and that we have created two collection
side which is orders and customer will
now be backed up now for that you have
to just simply use the dump
keyword
and click enter so it will just process
and it says done dumping simply code one
dot new employees and on all right so
let's just go back to our
folder here and see whether or not we
have created a backup right so where you
can see the backup and inside backup now
we have a dump folder and inside that we
have all the database names which is
admin company DB mongodb backup simply
code one student DB test we have
recently created this mongodb backup
click on that and you can see we have
the data in the form of based on format
which is of customers as well as the
orders so that means you have
successfully uh copied the data from
your mongodb instance to your local uh
system wherein you have downloaded the
data from the database and you have
inserted you have basically backed up
into this folder here
so I hope you understood how to uh
basically perform the backup in your
mongodb database so let's say if I want
to drop this database so let's see how
does it work for that I'm using the
db.drop database command
make sure the D is capital otherwise it
will throw an error
so is it uh it says it is successfully
uh dropped the mongodb backup database
so let's again see the collections I
mean show DBS let's see if it is showing
or not so as you can see mongodb backup
is not there
in our uh you know list of uh the
databases that we are that have that are
available now
so we have to perform the restore option
here so for that I'll just go back uh to
the command prompt and I'll just simply
write restore
click enter it will process and it will
take some time
and finally you can see in the end of uh
the line here it says two documents
restored successfully so let's just go
back and let us now see
whether it is showing the mongodb backup
database or not so now you can see
mongodb backup is present in our list of
databases that are present in our
mongodb instance so again let's check
whether the collections have uh backed
up or not so for that I'm showing I'm
writing show collections command here so
as you can see customers and orders are
restored again backwards original state
without any uh issues over here so in
this way you can use the restore option
if you are in case you have deleted your
database or let's say if deleted the
information or the data from your
collections that are present in your
database
so till now we are basically backed up
all the collections that are present in
our database now what if you want to
create a backup of only a particular
collection now let's say I have the
customers collection here and I want to
only backup that and leave the orders so
for that we have to basically again go
back to our C drive and we'll just
create another file here okay
and the folder wherein will take let's
say backup one so we have created a new
uh backup one folder just copy paste
this
foreign
copy paste this and
go back to the command prompt
and now mention the current directory
which we are using is backup one all
right
so sensor basically uh backup backing up
only a particular folder now the command
would be dump
mentioned the DB database which is
mongodb backup
and mention the collection keyword and
mention the collection name which is
customers I think it's customers only
let's just yeah it's customers
so when you click on enter it will say
that done dumping mongodb backup dot
customers one document has been
successfully packed up so let's just
verify it uh go back to backup one so
you can see
now only the customers collection was
only uh backed up in our let's say which
we have created backup one folder now
I'll drop this uh only the particular
collection and will try to restore it
back to its original state so the
command would be DB dot mention the uh
collection name and mention the drop
keyword
so it says true that much it is
successfully uh dropped so let's just
check the collections and see whether it
is deleted or not so you can see only
orders uh collection has is been shown
in our uh you know database which is in
mongodb backup database all right so let
us now try to restore it just go back to
this command prompt and now the keyword
would be restore
in the same restore DB is the
keyword mentioned the database name
which is mongodb backup and mentioned
the collection name as well
just customers
Okay click enter
let's say zero scanning filescan file
dump is a directory not a piece on file
okay you have to provide the file path
also so I think I have
so let me just correct this uh just copy
paste the command till here
now what you have to do is you have to
provide the location of the backup
folder where you have created uh the
backup for the customers collection here
so just copy paste this
so I'm just mentioning the location of
where we have backed up our you know
customers collection here and it is also
saying that it is not a base one file
right so just uh keep the Slash and
mention the collection name and the file
format which is based on okay and I
think we are good to go now just click
enter
so now you can see that uh one document
restored successfully so let's just go
back to the mongodb shell and try to
verify whether it is restored or not so
I'm just creating again show collections
uh command so now you can see customers
order and the orders are both showing in
our collection set so that means we are
successfully restored the one which we
have deleted so in this way you can even
delete uh and backup and restore a
particular database collection as well
and with that we have reached the end of
the session on mongodb Basics course
hope the session was informative and
helpful we hope you had a lot to learn
and if you have any further queries
regarding any concepts or topics covered
in this tutorial feel free to let us
know in the comments below and a team of
experts will be more than happy to
assist you until next time thank you
stay safe and keep learning
thank you
hi there if you like this video
subscribe to the simply learning YouTube
channel and click here to watch similar
videos to nerd up and get certified
click here